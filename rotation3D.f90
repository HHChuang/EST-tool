! ###################################################################
! Copyright (c) 2013-2014, Marc De Graef/Carnegie Mellon University
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are 
! permitted provided that the following conditions are met:
!
!     - Redistributions of source code must retain the above copyright
!     notice, this list 
!        of conditions and the following disclaimer.
!     - Redistributions in binary form must reproduce the above
!     copyright notice, this 
!        list of conditions and the following disclaimer in the
!        documentation and/or 
!        other materials provided with the distribution.
!     - Neither the names of Marc De Graef, Carnegie Mellon University
!     nor the names 
!        of its contributors may be used to endorse or promote products
!        derived from 
!        this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" 
! AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
! THE 
! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
! PURPOSE 
! ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
! BE 
! LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
! CONSEQUENTIAL 
! DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
! GOODS OR 
! SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
! HOWEVER 
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
! LIABILITY, 
! OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
! THE 
! USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
! DAMAGE.
! ###################################################################

!--------------------------------------------------------------------------
! rotations3D.f90
!--------------------------------------------------------------------------
!
! MODULE: rotations3D
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief everything that has to do with rotations and conversions
!between rotations
!
!> @details This file relies a lot on the relations listed in the book
!"Orientations
!> and Rotations" by Adam Morawiec [Springer 2004].  I've tried to
!implement every
!> available representation for rotations in a way that makes it easy to
!convert 
!> between any pair.  Needless to say, this needs extensive testing and
!debugging...
!>
!> Instead of converting all the time between representations, I've
!opted to 
!> "waste" a little more memory and time and provide the option to
!precompute all the representations.
!> This way all representations are available via a single data
!structure.
!>
!> Obviously, the individual conversion routines also exist and can be
!called either in
!> single or in double precision (using a function interface for each
!call, so that only
!> one function name is used).  The conversion routines use the
!following format for their
!> call name:  ab2cd, where (ab and cd are two-characters strings
!selected from the following
!> possibilities: [the number in parenthesis lists the number of entries
!that need to be provided] 
!>
!> eu : euler angle representation (3)
!> om : orientation matrix representation (3x3)
!> ax : axis angle representation (4)
!> ro : Rodrigues vector representation (4)
!> qu : unit quaternion representation (4)
!> ho : homochoric representation (3)
!> cu : cubochoric representation (3).
!>
!> hence, conversion from homochoric to euler angle is called as
!ho2eu(); the argument of 
!> each routine must have the correct number of dimensions and entries.
!> All 42 conversion routines exist in both single and double precision.
!>
!> Some routines were modified in July 2014, to simplify the paths in
!case the direct conversion
!> routine does not exist.  Given the complexity of the cubochoric
!transformations, all routines
!> going to and from this representation will require at least one and
!sometimes two or three
!> intermediate representations.  cu2eu and qu2cu currently represent
!the longest computation 
!> paths with three intermediate steps each.
!>
!> In August 2014, all routines were modified to account for active vs.
!passive rotations,
!> after some inconsistencies were discovered that could be traced back
!to that distinction.
!> The default is for a rotation to be passive, and only those
!transformation rules have been
!> implemented.  For active rotations, the user needs to explicitly take
!action in the calling 
!> program by setting the correct option in the ApplyRotation function.
!>
!> Testing: the program rotationtest.f90 was generated by an IDL script
!and contains all possible
!> pairwise and triplet transformations, using a series of input angle
!combinations; these
!> are potentially problematic Euler combinations.
!>
!> Compilation: this module was successfully compiled with the gfortran
!compiler (4.9.0) on a Mac OS X 10.9.3
!>
!> the following command compiles the module:
!>
!> gfortran -c rotations3D.f90      [this creates the .o and .mod files)
!>
!> gfortran -o out rotationtest.f90 rotations3D.o -llapack -lblas  [this
!compiles the rotationtest.f90 program]
!>
!> ./out  [run the executable using rotations.txt as the input file...]
!>
!
!> @date 08/04/13 MDG 1.0 original
!> @date 07/08/14 MDG 2.0 modifications to several routines (mostly
!simplifications)
!> @date 08/08/14 MDG 3.0 added active/passive handling (all routines
!passive)
!> @date 08/11/14 MDG 3.1 modified Rodrigues vector to 4 components (n
!and length) to accomodate Infinity
!> @date 08/18/14 MDG 3.2 added RotateVector, RotateTensor2 routines
!with active/passive switch
!> @date 08/20/14 MDG 3.3 completed extensive testing of epsijk<0 mode;
!all tests passed for the first time !
!> @date 08/21/14 MDG 3.4 minor correction in om2ax to get things to
!work for epsijk>0 mode; all tests passed!
!> @date 08/22/14 MDG 4.0 extracted from CTEMsoft package into
!standalone module
!--------------------------------------------------------------------------
module rotations3D



!--------------------------------------------------------------------------
!-----------------variable kind
!definitions--------------------------------
!--------------------------------------------------------------------------

! Define the "kind" parameters for single and double precision reals, 
!> single precision real kind parameter
  integer,parameter                     :: sgl =
SELECTED_REAL_KIND(p=6,r=37)   
!> double precision real kind parameter
  integer,parameter                     :: dbl =
SELECTED_REAL_KIND(p=13,r=200) 

! Define the "kind" parameters for short and regular integers,
!> short integer kind parameter 
  integer,parameter                     :: ish = SELECTED_INT_KIND(3) 
!> long integer kind parameter  
  integer,parameter                     :: irg = SELECTED_INT_KIND(9)



!--------------------------------------------------------------------------
!--------------------constants---------------------------------------------
!--------------------------------------------------------------------------


! ****************************************************
! ****************************************************
! ****************************************************
! used to change the sign of the permutation symbol from Adam Morawiec's
! book to
! the convention used for the CTEMsoft package.  If you want to use
! Adam's convention,
! both of these parameters should be set to +1; -1 will change the sign
! everywhere
! for all representations that involve the unit vector.

! uncomment these for the more logical way of doing things
real(kind=sgl), parameter :: epsijk = -1.0
real(kind=dbl), parameter :: epsijkd = -1.D0

! uncomment these for the Morawiec version.
!real(kind=sgl), parameter :: epsijk = 1.0
!real(kind=dbl), parameter :: epsijkd = 1.D0
! ****************************************************
! ****************************************************
! ****************************************************


! the rotations.f90 routines need to have access to the value +Infinity
! which is defined here (using the LaTeX name infty)
INTEGER,private :: inf
REAL,public :: infty
EQUIVALENCE (inf,infty) !Stores two variable at the same address
DATA inf/z'7f800000'/ !Hex for +Infinity

real(kind=dbl), parameter :: cPi=3.141592653589793238D0


! these are a bunch of constants used for Lambert and related
! projections; they are all in double precision
type LambertParametersType
        real(kind=dbl)          :: Pi=3.141592653589793D0       !  pi
        real(kind=dbl)          :: iPi=0.318309886183791D0      !  1/pi
        real(kind=dbl)          :: sPi=1.772453850905516D0      !
sqrt(pi)
        real(kind=dbl)          :: sPio2=1.253314137315500D0    !
sqrt(pi/2)
        real(kind=dbl)          :: sPi2=0.886226925452758D0     !
sqrt(pi)/2
        real(kind=dbl)          :: srt=0.866025403784439D0      !
sqrt(3)/2
        real(kind=dbl)          :: isrt=0.577350269189626D0    !
1/sqrt(3)
        real(kind=dbl)          :: alpha=1.346773687088598D0   !
sqrt(pi)/3^(1/4)
        real(kind=dbl)          :: rtt=1.732050807568877D0      !
sqrt(3)
        real(kind=dbl)          :: prea=0.525037567904332D0    !
3^(1/4)/sqrt(2pi)
        real(kind=dbl)          :: preb=1.050075135808664D0     !
3^(1/4)sqrt(2/pi)
        real(kind=dbl)          :: prec=0.906899682117109D0    !
pi/2sqrt(3)
        real(kind=dbl)          :: pred=2.094395102393195D0     !  2pi/3
        real(kind=dbl)          :: pree=0.759835685651593D0     !
3^(-1/4)
        real(kind=dbl)          :: pref=1.381976597885342D0     !
sqrt(6/pi)
! the following constants are used for the cube to quaternion hemisphere
! mapping
        real(kind=dbl)          :: a=1.925749019958253D0        !
pi^(5/6)/6^(1/6)
        real(kind=dbl)          :: ap=2.145029397111025D0       !
pi^(2/3)
        real(kind=dbl)          :: sc=0.897772786961286D0       ! a/ap
        real(kind=dbl)          :: beta=0.962874509979126D0     !
pi^(5/6)/6^(1/6)/2
        real(kind=dbl)          :: R1=1.330670039491469D0       !
(3pi/4)^(1/3)
        real(kind=dbl)          :: r2=1.414213562373095D0       !
sqrt(2)
        real(kind=dbl)          :: r22=0.707106781186547D0      !
1/sqrt(2)
        real(kind=dbl)          :: pi12=0.261799387799149D0     ! pi/12
        real(kind=dbl)          :: pi8=0.392699081698724D0      ! pi/8
        real(kind=dbl)          :: prek=1.643456402972504D0     ! R1
2^(1/4)/beta
        real(kind=dbl)          :: r24=4.898979485566356D0      !
sqrt(24)
        real(kind=dbl)          :: omegamax = 3.141592479056868D0
! max angle (radians)  for Rodrigues space, currently 179.99999¡
        real(kind=dbl)          :: rvmax2=131312254114241.4843750000D0
! square of max rodrigues vector length (reset when omegamax changes)  
        real(kind=dbl)          :: tfit(16) = (/1.0000000000018852D0,
-0.5000000002194847D0, & 
                                             -0.024999992127593126D0, -
0.003928701544781374D0, & 
                                             -0.0008152701535450438D0, -
0.0002009500426119712D0, & 
                                             -0.00002397986776071756D0,
- 0.00008202868926605841D0, & 
                                             +0.00012448715042090092D0,
- 0.0001749114214822577D0, & 
                                             +0.0001703481934140054D0, -
0.00012062065004116828D0, & 
                                             +0.000059719705868660826D0,
- 0.00001980756723965647D0, & 
                                             +0.000003953714684212874D0,
- 0.00000036555001439719544D0 /)
    real(kind=dbl)              :: BP(6)= (/ 0.D0, 1.D0,
0.577350269189626D0, 0.414213562373095D0, 0.D0,  &
                                              0.267949192431123D0 /)
! used for Fundamental Zone determination
end type LambertParametersType

type(LambertParametersType)        :: LPs


!--------------------------------------------------------------------------
!--------------------orientation
!types-------------------------------------
!--------------------------------------------------------------------------

! the "orientation" type contains entries for all rotation and
! orientation representations
type orientationtype
  real(kind=sgl)        :: eulang(3)            ! Bunge Euler angles in
radians
  real(kind=sgl)        :: om(3,3)              ! 3x3 matrix
  real(kind=sgl)        :: axang(4)             ! axis-angle pair (angle
in rad, component 4; axis in direction cosines)
  real(kind=sgl)        :: rodrigues(4)         ! Rodrigues vector
(stored as direction cosines and length, to allow for Infinity)
  real(kind=sgl)        :: quat(4)              ! quaternion
representation (q(1) is scalar part, q(2:4) vector part)
  real(kind=sgl)        :: homochoric(3)        ! homochoric
representation according to Frank's paper  
  real(kind=sgl)        :: cubochoric(3)        ! cubic grid
representation (derived from homochoric)
end type orientationtype


! double precision version
type orientationtyped
  real(kind=dbl)        :: eulang(3)            ! Bunge Euler angles in
radians
  real(kind=dbl)        :: om(3,3)              ! 3x3 matrix
  real(kind=dbl)        :: axang(4)             ! axis-angle pair (angle
in rad, component 4; axis in direction cosines)
  real(kind=dbl)        :: rodrigues(4)         ! Rodrigues vector
(stored as direction cosines and length, to allow for Infinity)
  real(kind=dbl)        :: quat(4)              ! quaternion
representation (q(1) is scalar part, q(2:4) vector part)
  real(kind=dbl)        :: homochoric(3)        ! homochoric
representation according to Frank's paper  
  real(kind=dbl)        :: cubochoric(3)        ! cubic grid
representation (derived from homochoric)
end type orientationtyped


!--------------------------------------------------------------------------
!---------------function and subroutine
!interfaces-------------------------
!--------------------------------------------------------------------------

interface WriteValue
        module procedure WriteValueIntShort
        module procedure WriteValueIntLong
        module procedure WriteValueRealSingle
        module procedure WriteValueRealDouble
        module procedure WriteValueRealComplex
        module procedure WriteValueString
end interface WriteValue


! quaternion multiplication (single and double precision)
public :: quat_mult
interface quat_mult
     module procedure quat_mult
     module procedure quat_mult_d
  end interface

! complex conjugation (single and double precision)
intrinsic :: conjg
public :: conjg
interface conjg
     module procedure quat_conjg
     module procedure quat_conjg_d
  end interface

! mappings from the 3D cubic grid to the 3D spherical grid
public :: LambertCubeToBall
interface LambertCubeToBall
        module procedure Lambert3DCubeForwardSingle
        module procedure Lambert3DCubeForwardDouble
end interface

public :: LambertBallToCube
interface LambertBallToCube
        module procedure Lambert3DCubeInverseSingle
        module procedure Lambert3DCubeInverseDouble
end interface

! general interface routine to populate the orientation type
public:: init_orientation
interface init_orientation
        module procedure init_orientation
        module procedure init_orientation_om
        module procedure init_orientation_d
        module procedure init_orientation_om_d
end interface


! convert Euler angles to 3x3 orientation matrix
public :: eu2om
interface eu2om
        module procedure eu2om
        module procedure eu2om_d
end interface

! convert Euler angles to axis angle
public :: eu2ax
interface eu2ax
        module procedure eu2ax
        module procedure eu2ax_d
end interface

! convert Euler angles to Rodrigues vector
public :: eu2ro
interface eu2ro
        module procedure eu2ro
        module procedure eu2ro_d
end interface

! convert Euler angles to quaternion
public :: eu2qu
interface eu2qu
        module procedure eu2qu
        module procedure eu2qu_d
end interface

! convert Euler angles to homochoric
public :: eu2ho
interface eu2ho
        module procedure eu2ho
        module procedure eu2ho_d
end interface

! convert Euler angles to cubochoric
public :: eu2cu
interface eu2cu
        module procedure eu2cu
        module procedure eu2cu_d
end interface

!--------------------------------
! convert 3x3 orientation matrix to Euler angles
public :: om2eu
interface om2eu
        module procedure om2eu
        module procedure om2eu_d
end interface

! convert 3x3 orientation matrix to axis angle
public :: om2ax
interface om2ax
        module procedure om2ax
        module procedure om2ax_d
end interface

! convert 3x3 orientation matrix to Rodrigues
public :: om2ro
interface om2ro
        module procedure om2ro
        module procedure om2ro_d
end interface

! convert 3x3 rotation matrix to quaternion
public :: om2qu
interface om2qu
        module procedure om2qu
        module procedure om2qu_d
end interface

! convert 3x3 rotation matrix to homochoric
public :: om2ho
interface om2ho
        module procedure om2ho
        module procedure om2ho_d
end interface

! convert 3x3 rotation matrix to cubochoric
public :: om2cu
interface om2cu
        module procedure om2cu
        module procedure om2cu_d
end interface

!--------------------------------
! convert axis angle pair to euler
public :: ax2eu
interface ax2eu
        module procedure ax2eu
        module procedure ax2eu_d
end interface

! convert axis angle pair to orientation matrix
public :: ax2om
interface ax2om
        module procedure ax2om
        module procedure ax2om_d
end interface

! convert axis angle pair to Rodrigues
public :: ax2ro
interface ax2ro
        module procedure ax2ro
        module procedure ax2ro_d
end interface

! convert axis angle pair to quaternion
public :: ax2qu
interface ax2qu
        module procedure ax2qu
        module procedure ax2qu_d
end interface

! convert axis angle pair to homochoric representation
public :: ax2ho
interface ax2ho
        module procedure ax2ho
        module procedure ax2ho_d
end interface

! convert axis angle pair to cubochoric
public :: ax2cu
interface ax2cu
        module procedure ax2cu
        module procedure ax2cu_d
end interface

!--------------------------------
! convert Rodrigues vector to Euler angles
public :: ro2eu
interface ro2eu
        module procedure ro2eu
        module procedure ro2eu_d
end interface

! convert Rodrigues vector to orientation matrix
public :: ro2om
interface ro2om
        module procedure ro2om
        module procedure ro2om_d
end interface

! convert Rodrigues vector to axis angle pair
public :: ro2ax
interface ro2ax
        module procedure ro2ax
        module procedure ro2ax_d
end interface

! convert Rodrigues vector to quaternion
public :: ro2qu
interface ro2qu
        module procedure ro2qu
        module procedure ro2qu_d
end interface

! convert Rodrigues vector to homochoric
public :: ro2ho
interface ro2ho
        module procedure ro2ho
        module procedure ro2ho_d
end interface

! convert Rodrigues vector to cubochoric
public :: ro2cu
interface ro2cu
        module procedure ro2cu
        module procedure ro2cu_d
end interface

!--------------------------------
! convert quaternion to Euler angles
public :: qu2eu
interface qu2eu
        module procedure qu2eu
        module procedure qu2eu_d
end interface

! convert quaternion to orientation matrix 
public :: qu2om
interface qu2om
        module procedure qu2om
        module procedure qu2om_d
end interface

! convert quaternion to axis angle
public :: qu2ax
interface qu2ax
        module procedure qu2ax
        module procedure qu2ax_d
end interface

! convert quaternion to Rodrigues
public :: qu2ro
interface qu2ro
        module procedure qu2ro
        module procedure qu2ro_d
end interface

! convert quaternion to homochoric
public :: qu2ho
interface qu2ho
        module procedure qu2ho
        module procedure qu2ho_d
end interface

! convert quaternion to cubochoric
public :: qu2cu
interface qu2cu
        module procedure qu2cu
        module procedure qu2cu_d
end interface

!--------------------------------
! convert homochoric to euler
public :: ho2eu
interface ho2eu
        module procedure ho2eu
        module procedure ho2eu_d
end interface

! convert homochoric to orientation matrix 
public :: ho2om
interface ho2om
        module procedure ho2om
        module procedure ho2om_d
end interface

! convert homochoric to axis angle pair 
public :: ho2ax
interface ho2ax
        module procedure ho2ax
        module procedure ho2ax_d
end interface

! convert homochoric to Rodrigues 
public :: ho2ro
interface ho2ro
        module procedure ho2ro
        module procedure ho2ro_d
end interface

! convert homochoric to quaternion
public :: ho2qu
interface ho2qu
        module procedure ho2qu
        module procedure ho2qu_d
end interface

! convert homochoric to cubochoric
public :: ho2cu
interface ho2cu
        module procedure ho2cu
        module procedure ho2cu_d
end interface

!--------------------------------
! convert cubochoric to euler
public :: cu2eu
interface cu2eu
        module procedure cu2eu
        module procedure cu2eu_d
end interface

! convert cubochoric to orientation matrix
public :: cu2om
interface cu2om
        module procedure cu2om
        module procedure cu2om_d
end interface

! convert cubochoric to axis angle
public :: cu2ax
interface cu2ax
        module procedure cu2ax
        module procedure cu2ax_d
end interface

! convert cubochoric to Rodrigues
public :: cu2ro
interface cu2ro
        module procedure cu2ro
        module procedure cu2ro_d
end interface

! convert cubochoric to quaternion
public :: cu2qu
interface cu2qu
        module procedure cu2qu
        module procedure cu2qu_d
end interface

! convert cubochoric to homochoric
public :: cu2ho
interface cu2ho
        module procedure cu2ho
        module procedure cu2ho_d
end interface

! apply a rotation to a vector
public :: RotateVector
interface RotateVector
        module procedure RotVec_om
        module procedure RotVec_om_d
        module procedure RotVec_qu
        module procedure RotVec_qu_d
end interface

! apply a rotation to a second rank tensor
public :: RotateTensor2
interface RotateTensor2
        module procedure RotTensor2_om
        module procedure RotTensor2_om_d
end interface


!--------------------------------
! print quaternion and equivalent 3x3 rotation matrix
public :: print_orientation
interface print_orientation
        module procedure print_orientation
        module procedure print_orientation_d
end interface



contains

!--------------------------------------------------------------------------
!
! SUBROUTINE: Message
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief dump a message to standard output
!
!> @details Simple routine to print a string on the standard output,
!with optional formatting
!> instructions, for instance if one wants an empty line before
!(frm='(/A)') or after (frm='(A/)') 
!> the string.  Note that one can include the name of the optional
!variable in the subroutine
!> call, as in:
!> call Message('this is a string', frm='(//A//)' , stdout = 22)
!> this makes it clear that frm and stdout are optional variables.
! 
!> @param mess message string
!> @param frm optional string formatting command
!> @param stdout optional output unit identifier
!
!> @date 01/05/99 MDG 1.0 original
!> @date 05/19/01 MDG 2.0 f90 version
!> @date 03/19/13 MDG 3.0 made argument optional and introduced default
!format
!> @date 06/05/14 MDG 4.0 added stdout and mess as mandatory arguments
!--------------------------------------------------------------------------
subroutine Message(mess,frm,stdout)

character(*),INTENT(IN)         :: mess         !< message string
character(*),OPTIONAL,INTENT(IN)        :: frm          !< optional
formatting string
integer(kind=irg),OPTIONAL,INTENT(IN)   :: stdout       !< optional
output unit identifier

integer(kind=irg)                       :: std

std = 6
if (PRESENT(stdout)) std = stdout

! default format or not ?
if (PRESENT(frm)) then
 write (std,fmt=frm) trim(mess)
else    ! default output format: a simple string
 write (std,fmt="(A)") trim(mess)
end if 

end subroutine Message

! ###################################################################
! 
!  subroutine WriteValueString 
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief write a string
!
!> @param Qstring question string
!> @param out_string output string
!> @param frm optional formatting argument
!> @param stdout optional output unit identifier
!
!> @date 03/19/13 MDG 1.0 new routine
!> @date 06/05/14 MDG 2.0 changed io handling
! ###################################################################
subroutine WriteValueString(Qstring, out_string, frm, stdout)

character(*),INTENT(IN)                 :: Qstring 
character(*),INTENT(IN)                 :: out_string
character(*),INTENT(IN),OPTIONAL                :: frm
integer(kind=irg),INTENT(IN),OPTIONAL           :: stdout

integer(kind=irg)                               :: std

std = 6
if (PRESENT(stdout)) std = stdout

! send Qstring to the output only if it is non-zero length
if (len(Qstring).ne.0) call Message(Qstring, frm = "(A$)", stdout = std)


if (PRESENT(frm)) then 
  call Message(out_string, frm = frm, stdout = std)
else
 call Message(out_string, frm = "(A)", stdout = std)
end if

end subroutine WriteValueString

! ###################################################################
! 
!  subroutine WriteValueIntShort 
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief write one or more short integers
!
!> @param Qstring question string
!> @param out_int output string
!> @param num optional number of integers
!> @param frm optional formatting argument
!> @param stdout optional output unit identifier
!
!> @date 03/19/13 MDG 1.0 new routine
!> @date 06/05/14 MDG 2.0 changed io handling
! ###################################################################
subroutine WriteValueIntShort(Qstring, out_int, num, frm, stdout)

character(*), INTENT(IN)                        :: Qstring
integer(kind=ish),INTENT(IN)                    :: out_int(*)
character(*),INTENT(IN),OPTIONAL                :: frm
integer(kind=irg),INTENT(IN),OPTIONAL           :: num
integer(kind=irg),INTENT(IN),OPTIONAL           :: stdout

integer(kind=irg)                               :: std

std = 6
if (PRESENT(stdout)) std = stdout

if (len(Qstring).ne.0) call Message(Qstring, frm = "(A$)", stdout = std)

! one or more than one values expected ?
if (PRESENT(num)) then
 if (PRESENT(frm)) then
  write (std, fmt=frm) (out_int(i),i=1,num)
 else
  write (std,*) (out_int(i),i=1,num)
 end if
else
 if (PRESENT(frm)) then
  write (std, fmt=frm) out_int(1)
 else
  write (std,*) out_int(1)
 end if
end if

end subroutine WriteValueIntShort

! ###################################################################
! 
!  subroutine WriteValueIntLong 
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief write one or more 4-byte integers
!
!> @param Qstring question string
!> @param out_int output string
!> @param num optional number of integers
!> @param frm optional formatting argument
!> @param stdout optional output unit identifier
!
!> @date 03/19/13 MDG 1.0 new routine
!> @date 06/05/14 MDG 2.0 changed io handling
! ###################################################################
subroutine WriteValueIntLong(Qstring, out_int, num, frm, stdout)

character(*), INTENT(IN)                        :: Qstring
integer(kind=irg),INTENT(IN)                    :: out_int(*)
character(*),INTENT(IN),OPTIONAL                :: frm
integer(kind=irg),INTENT(IN),OPTIONAL           :: num
integer(kind=irg),INTENT(IN),OPTIONAL           :: stdout

integer(kind=irg)                               :: std

std = 6
if (PRESENT(stdout)) std = stdout

if (len(Qstring).ne.0) call Message(Qstring, frm = "(A$)", stdout = std)

! one or more than one values expected ?
if (PRESENT(num)) then
 if (PRESENT(frm)) then
  write (std, fmt=frm) (out_int(i),i=1,num)
 else
  write (std,*) (out_int(i),i=1,num)
 end if
else
 if (PRESENT(frm)) then
  write (std, fmt=frm) out_int(1)
 else
  write (std,*) out_int(1)
 end if
end if

end subroutine WriteValueIntLong


! ###################################################################
! 
!  subroutine WriteValueRealSingle 
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief write one or more single precision reals
!
!> @param Qstring question string
!> @param out_real output string
!> @param num optional number of integers
!> @param frm optional formatting argument
!> @param stdout optional output unit identifier
!
!> @date 03/19/13 MDG 1.0 new routine
!> @date 06/05/14 MDG 2.0 changed io handling
! ###################################################################
subroutine WriteValueRealSingle(Qstring, out_real, num, frm, stdout)

character(*), INTENT(IN)                        :: Qstring
real(kind=sgl),INTENT(IN)                       :: out_real(*)
character(*),INTENT(IN),OPTIONAL                :: frm
integer(kind=irg),INTENT(IN),OPTIONAL           :: num
integer(kind=irg),INTENT(IN),OPTIONAL           :: stdout

integer(kind=irg)                               :: std

std = 6
if (PRESENT(stdout)) std = stdout

if (len(Qstring).ne.0) call Message(Qstring, frm = "(A$)", stdout = std)

! one or more than one values expected ?
if (PRESENT(num)) then
 if (PRESENT(frm)) then
  write (std, fmt=frm) (out_real(i),i=1,num)
 else
  write (std,*) (out_real(i),i=1,num)
 end if
else
 if (PRESENT(frm)) then
  write (std, fmt=frm) out_real(1)
 else
  write (std,*) out_real(1)
 end if
end if

end subroutine WriteValueRealSingle



! ###################################################################
! 
!  subroutine WriteValueRealDouble 
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief write one or more double precision reals
!
!> @param Qstring question string
!> @param out_real output string
!> @param num optional number of integers
!> @param frm optional formatting argument
!> @param stdout optional output unit identifier
!
!> @date 03/19/13 MDG 1.0 new routine
!> @date 06/05/14 MDG 2.0 changed io handling
! ###################################################################
subroutine WriteValueRealDouble(Qstring, out_real, num, frm, stdout)

character(*), INTENT(IN)                        :: Qstring
real(kind=dbl),INTENT(IN)                       :: out_real(*)
character(*),INTENT(IN),OPTIONAL                :: frm
integer(kind=irg),INTENT(IN),OPTIONAL           :: num
integer(kind=irg),INTENT(IN),OPTIONAL           :: stdout

integer(kind=irg)                               :: std

std = 6
if (PRESENT(stdout)) std = stdout

if (len(Qstring).ne.0) call Message(Qstring, frm = "(A$)", stdout = std)

! one or more than one values expected ?
if (PRESENT(num)) then
 if (PRESENT(frm)) then
  write (std, fmt=frm) (out_real(i),i=1,num)
 else
  write (std,*) (out_real(i),i=1,num)
 end if
else
 if (PRESENT(frm)) then
  write (std, fmt=frm) out_real(1)
 else
  write (std,*) out_real(1)
 end if
end if

end subroutine WriteValueRealDouble


! ###################################################################
! 
!  subroutine WriteValueRealComplex 
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief write one or more single precision complex numbers
!
!> @param Qstring question string
!> @param out_real output string
!> @param num optional number of integers
!> @param frm optional formatting argument
!> @param stdout optional output unit identifier
!
!> @date 03/19/13 MDG 1.0 new routine
!> @date 06/05/14 MDG 2.0 changed io handling
! ###################################################################
subroutine WriteValueRealComplex(Qstring, out_cmplx, num, frm, stdout)

character(*), INTENT(IN)                        :: Qstring
complex(kind=sgl),INTENT(IN)                    :: out_cmplx(*)
character(*),INTENT(IN),OPTIONAL                :: frm
integer(kind=irg),INTENT(IN),OPTIONAL           :: num
integer(kind=irg),INTENT(IN),OPTIONAL           :: stdout

integer(kind=irg)                               :: std

std = 6
if (PRESENT(stdout)) std = stdout

if (len(Qstring).ne.0) call Message(Qstring, frm = "(A$)", stdout = std)

! one or more than one values expected ?
if (PRESENT(num)) then
 if (PRESENT(frm)) then
  write (std, fmt=frm) (out_cmplx(i),i=1,num)
 else
  write (std,*) (out_cmplx(i),i=1,num)
 end if
else
 if (PRESENT(frm)) then
  write (std, fmt=frm) out_cmplx(1)
 else
  write (std,*) out_cmplx(1)
 end if
end if

end subroutine WriteValueRealComplex

!--------------------------------------------------------------------------
!
! FUNCTION: quat_mult
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief quaternion multiplication   (single precision)
!
!> @param x first quaternion 
!> @param y second quaternion 
! 
!> @date 3/15/12   MDG 1.0 original
!> @date 8/12/13   MDG 2.0 rewrite
!--------------------------------------------------------------------------
recursive function quat_mult(x,y) result (res)

    real(kind=sgl), intent(in)          :: x(4), y(4)           !< input
quaternions
    real(kind=sgl)                      :: res(4)

    res = (/ x(1)*y(1) - x(2)*y(2) - x(3)*y(3) - x(4)*y(4), &
             x(1)*y(2) + x(2)*y(1) + x(3)*y(4) - x(4)*y(3), &
             x(1)*y(3) - x(2)*y(4) + x(3)*y(1) + x(4)*y(2), &
             x(1)*y(4) + x(2)*y(3) - x(3)*y(2) + x(4)*y(1) /)
    
end function quat_mult

!--------------------------------------------------------------------------
!
! FUNCTION: quat_mult_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief quaternion multiplication   (double precision)
!
!> @param x first quaternion 
!> @param y second quaternion 
! 
!> @date 3/15/12   MDG 1.0 original
!> @date 8/12/13   MDG 2.0 rewrite
!--------------------------------------------------------------------------
recursive function quat_mult_d(x,y) result (res)

    real(kind=dbl), intent(in)          :: x(4), y(4)           !< input
quaternions
    real(kind=dbl)                      :: res(4)

    res = (/ x(1)*y(1) - x(2)*y(2) - x(3)*y(3) - x(4)*y(4), &
             x(1)*y(2) + x(2)*y(1) + x(3)*y(4) - x(4)*y(3), &
             x(1)*y(3) - x(2)*y(4) + x(3)*y(1) + x(4)*y(2), &
             x(1)*y(4) + x(2)*y(3) - x(3)*y(2) + x(4)*y(1) /)

end function quat_mult_d

!--------------------------------------------------------------------------
!
! FUNCTION: quat_conjg
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief quaternion complex conjugation (extends intrinsic routine
!conjg)
!
!> @param x quaternion to be conjugated (single precision)
! 
!> @date 3/15/12   MDG 1.0 original
!> @date 8/12/13   MDG 2.0 rewrite
!--------------------------------------------------------------------------
recursive function quat_conjg(x) result (res)

    real(kind=sgl), intent(in)          :: x(4)         !< input
quaternion
    real(kind=sgl)                      :: res(4)

    res = (/ x(1), -x(2), -x(3), -x(4) /)

end function quat_conjg

!--------------------------------------------------------------------------
!
! FUNCTION: quat_conjg_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief quaternion complex conjugation (extends intrinsic routine
!conjg)
!
!> @param x quaternion to be conjugated (double precision)
! 
!> @date 3/15/12   MDG 1.0 original
!> @date 8/12/13   MDG 2.0 rewrite
!--------------------------------------------------------------------------
recursive function quat_conjg_d(x) result (res)

    real(kind=dbl), intent(in)          :: x(4)         !< input
quaternion
    real(kind=dbl)                      :: res(4)

    res = (/ x(1), -x(2), -x(3), -x(4) /)

end function quat_conjg_d


!--------------------------------------------------------------------------
!
! FUNCTION: Lambert3DCubeForwardSingle
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief map from 3D cubic grid to 3D ball 
!
!> @param xyzin 3D coordinates to be considered (single precision)  
!> @param ierr error flag 0 = OK, 1 = 
! 
!> @date 7/12/13    MDG 1.0 original
!> @date 7/7/14  MDG 2.0 correction to cube edge length check
!--------------------------------------------------------------------------
recursive function Lambert3DCubeForwardSingle(xyzin,ierr) result(res)

IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: xyzin(3)
integer(kind=irg),INTENT(INOUT) :: ierr
real(kind=sgl)                  :: res(3)

real(kind=sgl)                  :: XYZ(3), sXYZ(3), T1, T2, c, s, q,
LamXYZ(3)
integer(kind=irg)               :: p

ierr = 0
if (maxval(abs(xyzin)).gt.LPs%ap/2) then
  res = (/ 0.0, 0.0, 0.0 /)
  ierr = 1
  return
end if

! determine which pyramid pair the point lies in and copy coordinates in
! correct order (see paper)
p = GetPyramidSingle(xyzin)
select case (p)
 case (1,2)
  sXYZ = xyzin
 case (3,4)
  sXYZ = (/ xyzin(2), xyzin(3), xyzin(1) /)
 case (5,6)
  sXYZ = (/ xyzin(3), xyzin(1), xyzin(2) /)
end select

! scale by grid parameter ratio sc
XYZ = LPs%sc * sXYZ

! transform to the sphere grid via the curved square, and intercept the
! zero point
if (maxval(abs(XYZ)).eq.0.0) then
  LamXYZ = (/ 0.0, 0.0, 0.0 /)
else
! intercept all the points along the z-axis
  if (maxval(abs(XYZ(1:2))).eq.0.0) then
    LamXYZ = (/ 0.0, 0.0, sngl(LPs%pref) * XYZ(3) /)
  else  ! this is a general grid point
    if (abs(XYZ(2)).le.abs(XYZ(1))) then
      q = LPs%pi12 * XYZ(2)/XYZ(1)
      c = cos(q)
      s = sin(q)
      q = LPs%prek * XYZ(1) / sqrt(LPs%r2-c)
      T1 = (LPs%r2*c - 1.0) * q
      T2 = LPs%r2 * s * q
    else
      q = LPs%pi12 * XYZ(1)/XYZ(2)
      c = cos(q)
      s = sin(q)
      q = LPs%prek * XYZ(2) / sqrt(LPs%r2-c)
      T1 = LPs%r2 * s * q
      T2 = (LPs%r2*c - 1.0) * q
    end if

! transform to sphere grid (inverse Lambert)
! [note that there is no need to worry about dividing by zero, since
! XYZ(3) can not become zero]
    c = T1**2+T2**2
    s = LPs%Pi * c/(24.0*XYZ(3)**2)
    c = LPs%sPi * c / LPs%r24 / XYZ(3)
    q = sqrt( 1.0 - s )
    LamXYZ = (/ T1 * q, T2 * q, sngl(LPs%pref) * XYZ(3) - c /)
  end if
end if

! reverse the coordinates back to the regular order according to the
! original pyramid number
select case (p)
 case (1,2)
  res = LamXYZ
 case (3,4)
  res = (/ LamXYZ(3), LamXYZ(1), LamXYZ(2) /)
 case (5,6)
  res = (/ LamXYZ(2), LamXYZ(3), LamXYZ(1) /)
end select

end function Lambert3DCubeForwardSingle

!--------------------------------------------------------------------------
!
! FUNCTION: Lambert3DCubeForwardDouble
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief map from 3D cubic grid to 3D ball 
!
!> @param xyzin 3D coordinates to be considered (double precision)  
!> @param ierr error flag 0 = OK, 1 = outside of unit cube
! 
!> @date 7/12/13    MDG 1.0 original
!> @date 7/7/14  MDG 2.0 correction to cube edge length check
!--------------------------------------------------------------------------
recursive function Lambert3DCubeForwardDouble(xyzin,ierr) result(res)

IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: xyzin(3)
integer(kind=irg),INTENT(INOUT) :: ierr
real(kind=dbl)                  :: res(3)

real(kind=dbl)                  :: XYZ(3), sXYZ(3), T1, T2, c, s, q,
LamXYZ(3), eps
integer(kind=irg)               :: p

eps = 1.0D-8

ierr = 0
!if (maxval(dabs(xyzin)).gt.LPs%ap/2.D0) then
if (maxval(dabs(xyzin)).gt.(LPs%ap/2.D0+eps)) then
  res = (/ 0.D0, 0.D0, 0.D0 /)
  ierr = 1
  return
end if

! determine which pyramid pair the point lies in and copy coordinates in
! correct order (see paper)
p = GetPyramidDouble(xyzin)
select case (p)
 case (1,2)
  sXYZ = xyzin
 case (3,4)
  sXYZ = (/ xyzin(2), xyzin(3), xyzin(1) /)
 case (5,6)
  sXYZ = (/ xyzin(3), xyzin(1), xyzin(2) /)
end select

! scale by grid parameter ratio sc
XYZ = LPs%sc * sXYZ

! transform to the sphere grid via the curved square, and intercept the
! zero point
if (maxval(dabs(XYZ)).eq.0.D0) then
  LamXYZ = (/ 0.D0, 0.D0, 0.D0 /)
else
! intercept all the points along the z-axis
  if (maxval(dabs(XYZ(1:2))).eq.0.D0) then
    LamXYZ = (/ 0.D0, 0.D0, LPs%pref * XYZ(3) /)
  else  ! this is a general grid point
    if (dabs(XYZ(2)).le.dabs(XYZ(1))) then
      c = dcos(LPs%pi12 * XYZ(2)/XYZ(1))
      s = dsin(LPs%pi12 * XYZ(2)/XYZ(1))
      q = LPs%prek * XYZ(1) / dsqrt(LPs%r2-c)
      T1 = (LPs%r2*c - 1.D0) * q
      T2 = LPs%r2 * s * q
    else
      c = dcos(LPs%pi12 * XYZ(1)/XYZ(2))
      s = dsin(LPs%pi12 * XYZ(1)/XYZ(2))
      q = LPs%prek * XYZ(2) / dsqrt(LPs%r2-c)
      T1 = LPs%r2 * s * q
      T2 = (LPs%r2*c - 1.D0) * q
    end if

! transform to sphere grid (inverse Lambert)
! [note that there is no need to worry about dividing by zero, since
! XYZ(3) can not become zero]
    c = T1**2+T2**2
    s = LPs%Pi * c/(24.D0*XYZ(3)**2)
    c = LPs%sPi * c / LPs%r24 / XYZ(3)
    q = dsqrt( 1.0 - s )
    LamXYZ = (/ T1 * q, T2 * q, LPs%pref * XYZ(3) - c /)
  end if
end if

! reverse the coordinates back to the regular order according to the
! original pyramid number
select case (p)
 case (1,2)
  res = LamXYZ
 case (3,4)
  res = (/ LamXYZ(3), LamXYZ(1), LamXYZ(2) /)
 case (5,6)
  res = (/ LamXYZ(2), LamXYZ(3), LamXYZ(1) /)
end select

end function Lambert3DCubeForwardDouble

!--------------------------------------------------------------------------
!
! FUNCTION: Lambert3DCubeInverseSingle
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief map from 3D ball to 3D cubic grid  
!
!> @param xyz 3D coordinates to be considered (single precision)  
!> @param ierr error flag 0 = OK, 1 = 
! 
!> @date 7/12/13    MDG 1.0 original
!> @date 8/12/14    MDG 1.1 fixed acos() problem
!--------------------------------------------------------------------------
recursive function Lambert3DCubeInverseSingle(xyz,ierr) result(res)

IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: xyz(3)
integer(kind=irg),INTENT(INOUT) :: ierr
real(kind=sgl)                  :: res(3)

real(kind=sgl)                  :: rs, xyz3(3), xyz2(3), qxy, q2xy,
sq2xy, q, ac, T1inv, T2inv, &
                                   xyz1(3), sx, sy, qx2y, sqx2y, tt
        
integer(kind=irg)               :: p

ierr = 0

rs = sqrt(sum(xyz*xyz))
if (rs.gt.LPs%R1) then 
  res = (/ 0.0,0.0,0.0 /) 
  ierr = 1
  return
end if

if (maxval(abs(xyz)).eq.0.0) then 
  res = (/ 0.0,0.0,0.0 /) 
  return
end if

! determine pyramid
p = GetPyramidSingle(xyz)
select case (p)
 case (1,2)
  xyz3 = xyz
 case (3,4)
  xyz3 = (/ xyz(2), xyz(3), xyz(1) /)
 case (5,6)
  xyz3 = (/ xyz(3), xyz(1), xyz(2) /)
end select

! inverse M_3
q = sqrt( 2.0*rs/(rs+abs(xyz3(3))) )
xyz2 = (/ xyz3(1) * q, xyz3(2) * q, (abs(xyz3(3))/xyz3(3)) * rs /
sngl(LPs%pref) /)

! inverse M_2
qxy = xyz2(1)*xyz2(1)+xyz2(2)*xyz2(2)
sx = 1.0
if (xyz2(1).ne.0.0)  sx = abs(xyz2(1))/xyz2(1) 
sy = 1.0
if (xyz2(2).ne.0.0)  sy = abs(xyz2(2))/xyz2(2)

if (qxy.ne.0.0) then 
 if (abs(xyz2(2)).le.abs(xyz2(1))) then 
  q2xy = qxy + xyz2(1)*xyz2(1)
  sq2xy = sqrt(q2xy)
  q = (LPs%beta/LPs%r2/LPs%R1) *
sqrt(q2xy*qxy/(q2xy-abs(xyz2(1))*sq2xy))
  tt = (xyz2(2)*xyz2(2)+abs(xyz2(1))*sq2xy)/LPs%r2/qxy 
  if (tt.gt.1.0) tt = 1.0
  if (tt.lt.-1.0) tt = -1.0
  ac = acos(tt)
  T1inv = q * sx
  T2inv = q * sy * ac/LPs%pi12
 else 
  qx2y = qxy + xyz2(2)*xyz2(2)
  sqx2y = sqrt(qx2y)
  q = (LPs%beta/LPs%r2/LPs%R1) *
sqrt(qx2y*qxy/(qx2y-abs(xyz2(2))*sqx2y))
  tt = (xyz2(1)*xyz2(1)+abs(xyz2(2))*sqx2y)/LPs%r2/qxy 
  if (tt.gt.1.0) tt = 1.0
  if (tt.lt.-1.0) tt = -1.0
  ac = acos(tt)
  T1inv = q * sx * ac/LPs%pi12
  T2inv = q * sy
 end if
else
 T1inv = 0.0
 T2inv = 0.0
end if

xyz1 = (/ T1inv, T2inv, xyz2(3) /)

! inverse M_1
xyz1 = xyz1 / LPs%sc

! reverst the coordinates back to the regular order according to the
! original pyramid number
select case (p)
 case (1,2)
  res = xyz1
 case (3,4)
  res = (/ xyz1(3), xyz1(1), xyz1(2) /)
 case (5,6)
  res = (/ xyz1(2), xyz1(3), xyz1(1) /)
end select

end function Lambert3DCubeInverseSingle

!--------------------------------------------------------------------------
!
! FUNCTION: Lambert3DCubeInverseDouble
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief map from 3D ball to 3D cubic grid  
!
!> @param xyz 3D coordinates to be considered (double precision)  
!> @param ierr error flag 0 = OK, 1 = 
! 
!> @date 7/12/13    MDG 1.0 original
!> @date 8/12/14    MDG 1.1 fixed dacos() problem
!--------------------------------------------------------------------------
recursive function Lambert3DCubeInverseDouble(xyz,ierr) result(res)

IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: xyz(3)
integer(kind=irg),INTENT(INOUT) :: ierr
real(kind=dbl)                  :: res(3)

real(kind=dbl)                  :: rs, xyz3(3), xyz2(3), qxy, q2xy,
sq2xy, q, ac, T1inv, T2inv, &
                                   xyz1(3), sx, sy, qx2y, sqx2y, tt
integer(kind=irg)               :: p

ierr = 0

rs = dsqrt(sum(xyz*xyz))
if (rs.gt.LPs%R1) then 
  res = (/ 0.D0,0.D0,0.D0 /) 
  ierr = 1
  return
end if

if (maxval(dabs(xyz)).eq.0.D0) then 
  res = (/ 0.D0,0.D0,0.D0 /) 
  return
end if

! determine pyramid
p = GetPyramidDouble(xyz)
select case (p)
 case (1,2)
  xyz3 = xyz
 case (3,4)
  xyz3 = (/ xyz(2), xyz(3), xyz(1) /)
 case (5,6)
  xyz3 = (/ xyz(3), xyz(1), xyz(2) /)
end select

! inverse M_3
q = dsqrt( 2.D0*rs/(rs+dabs(xyz3(3))) )
xyz2 = (/ xyz3(1) * q, xyz3(2) * q, (dabs(xyz3(3))/xyz3(3)) * rs /
LPs%pref /)

! inverse M_2
qxy = xyz2(1)*xyz2(1)+xyz2(2)*xyz2(2)
sx = 1.D0
if (xyz2(1).ne.0.D0)  sx = dabs(xyz2(1))/xyz2(1) 
sy = 1.D0
if (xyz2(2).ne.0.D0)  sy = dabs(xyz2(2))/xyz2(2)

if (qxy.ne.0.D0) then
 if (dabs(xyz2(2)).le.dabs(xyz2(1))) then 
  q2xy = qxy + xyz2(1)*xyz2(1)
  sq2xy = dsqrt(q2xy)
  q = (LPs%beta/LPs%r2/LPs%R1) *
dsqrt(q2xy*qxy/(q2xy-dabs(xyz2(1))*sq2xy))
  tt = (xyz2(2)*xyz2(2)+dabs(xyz2(1))*sq2xy)/LPs%r2/qxy 
  if (tt.gt.1.D0) tt = 1.D0
  if (tt.lt.-1.D0) tt = -1.D0
  ac = dacos(tt)
  T1inv = q * sx
  T2inv = q * sy * ac/LPs%pi12
 else 
  qx2y = qxy + xyz2(2)*xyz2(2)
  sqx2y = dsqrt(qx2y)
  q = (LPs%beta/LPs%r2/LPs%R1) *
dsqrt(qx2y*qxy/(qx2y-dabs(xyz2(2))*sqx2y))
  tt = (xyz2(1)*xyz2(1)+dabs(xyz2(2))*sqx2y)/LPs%r2/qxy 
  if (tt.gt.1.D0) tt = 1.D0
  if (tt.lt.-1.D0) tt = -1.D0
  ac = dacos(tt)
  T1inv = q * sx * ac/LPs%pi12
  T2inv = q * sy
 end if
else
  T1inv = 0.D0
  T2inv = 0.D0
end if
xyz1 = (/ T1inv, T2inv, xyz2(3) /)

! inverse M_1
xyz1 = xyz1 / LPs%sc

! reverst the coordinates back to the regular order according to the
! original pyramid number
select case (p)
 case (1,2)
  res = xyz1
 case (3,4)
  res = (/ xyz1(3), xyz1(1), xyz1(2) /)
 case (5,6)
  res = (/ xyz1(2), xyz1(3), xyz1(1) /)
end select

end function Lambert3DCubeInverseDouble


!--------------------------------------------------------------------------
!
! FUNCTION: GetPyramidSingle
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief determine to which pyramid a point in a cubic grid belongs
!
!> @param xyz 3D coordinates to be considered (single precision)  
! 
!> @date 11/21/12    MDG 1.0 original
!--------------------------------------------------------------------------
recursive function GetPyramidSingle(xyz) result(res)

IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: xyz(3) 
integer(kind=irg)               :: res, p

logical                         :: next

next = .TRUE.
if ((abs(xyz(1)).le.xyz(3)).and.(abs(xyz(2)).le.xyz(3))) then
  p = 1                         ! pyramid 1
  next = .FALSE.
end if  
if (next) then 
 if ((abs(xyz(1)).le.-xyz(3)).and.(abs(xyz(2)).le.-xyz(3))) then
  p = 2                         ! pyramid 2
  next = .FALSE.
 end if   
end if

if (next) then
 if ((abs(xyz(3)).le.xyz(1)).and.(abs(xyz(2)).le.xyz(1))) then
  p = 3                         ! pyramid 3
  next = .FALSE.
 end if  
end if
if (next) then
 if ((abs(xyz(3)).le.-xyz(1)).and.(abs(xyz(2)).le.-xyz(1))) then
  p = 4                         ! pyramid 4
  next = .FALSE.
 end if  
end if

if (next) then
 if ((abs(xyz(1)).le.xyz(2)).and.(abs(xyz(3)).le.xyz(2))) then
  p = 5                         ! pyramid 5
  next = .FALSE.
 end if  
end if
if (next) then
 if ((abs(xyz(1)).le.-xyz(2)).and.(abs(xyz(3)).le.-xyz(2))) then
  p = 6                         ! pyramid 6
  next = .FALSE.
 end if  
end if
res = p

end function GetPyramidSingle

!--------------------------------------------------------------------------
!
! FUNCTION: GetPyramidDouble
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief determine to which pyramid a point in a cubic grid belongs
!
!> @param xyz 3D coordinates to be considered (double precision)  
! 
!> @date 11/21/12    MDG 1.0 original
!--------------------------------------------------------------------------
recursive function GetPyramidDouble(xyz) result(res)

IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: xyz(3) 
integer(kind=irg)               :: res, p

logical                         :: next

next = .TRUE.
if ((dabs(xyz(1)).le.xyz(3)).and.(dabs(xyz(2)).le.xyz(3))) then
  p = 1                         ! pyramid 1
  next = .FALSE.
end if  
if (next) then
 if ((dabs(xyz(1)).le.-xyz(3)).and.(dabs(xyz(2)).le.-xyz(3))) then
  p = 2                         ! pyramid 2
  next = .FALSE.
 end if   
end if

if (next) then
 if ((dabs(xyz(3)).le.xyz(1)).and.(dabs(xyz(2)).le.xyz(1))) then
  p = 3                         ! pyramid 3
  next = .FALSE.
 end if 
end if 
if (next) then
 if ((dabs(xyz(3)).le.-xyz(1)).and.(dabs(xyz(2)).le.-xyz(1))) then
  p = 4                         ! pyramid 4
  next = .FALSE.
 end if  
end if

if (next) then
 if ((dabs(xyz(1)).le.xyz(2)).and.(dabs(xyz(3)).le.xyz(2))) then
  p = 5                         ! pyramid 5
  next = .FALSE.
 end if  
end if
if (next) then
 if ((dabs(xyz(1)).le.-xyz(2)).and.(dabs(xyz(3)).le.-xyz(2))) then
  p = 6                         ! pyramid 6
  next = .FALSE.
 end if  
end if

res = p

end function GetPyramidDouble


!--------------------------------------------------------------------------
!
! Function: init_orientation
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief take an orientation representation with 3 components and init
!all others (single precision)
!
!> @param orient 3-component vector (single precision)  
!> @param intype input type ['eu', 'ro', 'ho', 'cu']
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function init_orientation(orient,intype) result(res)

IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: orient(*)            ! 3 or 4
component orientation descriptor
character(2),INTENT(IN)         :: intype               ! describes
input type

type(orientationtype)           :: res
real(kind=sgl)                  :: r,neworient(4)

select case (intype)
        case ('eu')     ! Euler angles
                res%eulang = orient(1:3)
                res%om = eu2om(orient(1:3))
                res%quat = eu2qu(orient(1:3))
                res%rodrigues = eu2ro(orient(1:3))
                res%axang = eu2ax(res%eulang)
                res%homochoric = ax2ho(res%axang)
                res%cubochoric = ho2cu(res%homochoric)
        case ('ro')     ! Rodrigues vector
                res%rodrigues = orient(1:4)
                res%eulang = ro2eu(orient(1:4))
                res%om = eu2om(res%eulang)
                res%quat = eu2qu(res%eulang)
                res%axang = ro2ax(res%rodrigues)
                res%homochoric = ax2ho(res%axang)
                res%cubochoric = ho2cu(res%homochoric)
        case ('ho')     ! homochoric
                res%homochoric = orient(1:3)
                res%axang = ho2ax(orient(1:3))
                res%om = ax2om(res%axang)
                res%eulang = om2eu(res%om)
                res%rodrigues = eu2ro(res%eulang)
                res%quat = eu2qu(res%eulang)
                res%cubochoric = ho2cu(res%homochoric)
        case ('cu')     ! cubochoric
                res%cubochoric = orient(1:3)
                res%homochoric = cu2ho(res%cubochoric)
                res%eulang = cu2eu(res%cubochoric)
                res%om = cu2om(res%cubochoric)
                res%quat = cu2qu(res%cubochoric)
                res%axang = cu2ax(res%cubochoric)
                res%rodrigues = cu2ro(res%cubochoric)
        case ('qu')     ! quaternion
                res%quat = orient(1:4)
                res%eulang = qu2eu(res%quat)
                res%om = eu2om(res%eulang)
                res%rodrigues = eu2ro(res%eulang)
                res%axang = ro2ax(res%rodrigues)
                res%homochoric = ax2ho(res%axang)
                res%cubochoric = ho2cu(res%homochoric)
        case ('ax')     ! axis angle pair
                r = sqrt(sum(orient(1:3)**2))
! normalize, just in case...
                neworient(1:3) = orient(1:3)/r
                neworient(4) = orient(4)
                res%axang = neworient
                res%om = ax2om(neworient)
                res%eulang = om2eu(res%om)
                res%rodrigues = eu2ro(res%eulang)
                res%quat = eu2qu(res%eulang)
                res%homochoric = ax2ho(res%axang)
                res%cubochoric = ho2cu(res%homochoric)
end select 

end function init_orientation

!--------------------------------------------------------------------------
!
! Function: init_orientation_3_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief take an orientation representation with 3 components and init
!all others (double precision)
!
!> @param orient 3-component vector (double precision)  
!> @param intype input type ['eu', 'ro', 'ho', 'cu']
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function init_orientation_d(orient,intype) result(res)

IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: orient(*)            ! 3-component
orientation descriptor
character(2),INTENT(IN)         :: intype               ! describes
input type

type(orientationtyped)          :: res

real(kind=dbl)                  :: r, neworient(4)

select case (intype)
        case ('eu')     ! Euler angles
                res%eulang = orient(1:3)
                res%om = eu2om_d(orient(1:3))
                res%quat = eu2qu_d(orient(1:3))
                res%rodrigues = eu2ro_d(orient(1:3))
                res%axang = eu2ax_d(res%eulang)
                res%homochoric = ax2ho_d(res%axang)
                res%cubochoric = ho2cu_d(res%homochoric)
        case ('ro')     ! Rodrigues vector
                res%rodrigues = orient(1:4)
                res%eulang = ro2eu_d(orient(1:4))
                res%om = eu2om_d(res%eulang)
                res%quat = eu2qu_d(res%eulang)
                res%axang = ro2ax_d(res%rodrigues)
                res%homochoric = ax2ho_d(res%axang)
                res%cubochoric = ho2cu_d(res%homochoric)
        case ('ho')     ! homochoric
                res%homochoric = orient(1:3)
                res%axang = ho2ax_d(orient(1:3))
                res%om = ax2om_d(res%axang)
                res%eulang = om2eu_d(res%om)
                res%rodrigues = eu2ro_d(res%eulang)
                res%quat = eu2qu_d(res%eulang)
                res%cubochoric = ho2cu_d(res%homochoric)
        case ('cu')     ! cubochoric
                res%cubochoric = orient(1:3)
                res%homochoric = cu2ho_d(res%cubochoric)
                res%eulang = cu2eu_d(res%cubochoric)
                res%om = cu2om_d(res%cubochoric)
                res%quat = cu2qu_d(res%cubochoric)
                res%axang = cu2ax_d(res%cubochoric)
                res%rodrigues = cu2ro_d(res%cubochoric)
        case ('qu')     ! quaternion
                res%quat = orient(1:4)
                res%eulang = qu2eu_d(res%quat)
                res%om = eu2om_d(res%eulang)
                res%rodrigues = eu2ro_d(res%eulang)
                res%axang = ro2ax_d(res%rodrigues)
                res%homochoric = ax2ho_d(res%axang)
                res%cubochoric = ho2cu_d(res%homochoric)
        case ('ax')     ! axis angle pair
                r = dsqrt(sum(orient(1:3)**2))
! normalize, just in case...
                neworient(1:3) = orient(1:3)/r
                neworient(4) = orient(4)
                res%axang = neworient
                res%om = ax2om_d(neworient)
                res%eulang = om2eu_d(res%om)
                res%rodrigues = eu2ro_d(res%eulang)
                res%quat = eu2qu_d(res%eulang)
                res%homochoric = ax2ho_d(res%axang)
                res%cubochoric = ho2cu_d(res%homochoric)
end select 

end function init_orientation_d

!--------------------------------------------------------------------------
!
! Function: init_orientation_om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief take an orientation representation with 3x3 components and
!init all others (single precision)
!
!> @param orient r-component vector (single precision)  
!> @param intype input type ['om']
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function init_orientation_om(orient,intype) result(res)

IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: orient(3,3)          ! 3x3-component
orientation descriptor
character(2),INTENT(IN)         :: intype               ! describes
input type

type(orientationtype)           :: res

select case (intype)
        case ('om')     ! orientation matrix
                res%om = orient
                res%quat = om2qu(orient)
                res%eulang = qu2eu(res%quat)
                res%rodrigues = eu2ro(res%eulang)
                res%axang = ro2ax(res%rodrigues)
                res%homochoric = ax2ho(res%axang)
                res%cubochoric = ho2cu(res%homochoric)
end select 

end function init_orientation_om


!--------------------------------------------------------------------------
!
! Function: init_orientation_om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief take an orientation representation with 3x3 components and
!init all others (double precision)
!
!> @param orient r-component vector (double precision)  
!> @param intype input type ['om']
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function init_orientation_om_d(orient,intype) result(res)

IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: orient(3,3)          ! 3x3-component
orientation descriptor
character(2),INTENT(IN)         :: intype               ! describes
input type

type(orientationtyped)          :: res

select case (intype)
        case ('om')     ! orientation matrix
                res%om = orient
                res%quat = om2qu_d(orient)
                res%eulang = qu2eu_d(res%quat)
                res%rodrigues = eu2ro_d(res%eulang)
                res%axang = ro2ax_d(res%rodrigues)
                res%homochoric = ax2ho_d(res%axang)
                res%cubochoric = ho2cu_d(res%homochoric)
end select 

end function init_orientation_om_d





!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
! here we start with a series of conversion routines between
! representations
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
!
! Function: eu2om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Euler angles to orientation matrix (single precision)
![Morawiec, page 28]
!
!> @param e 3 Euler angles in radians (single precision)  
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!> @data 7/23/14   MDG 1.1 verified
!--------------------------------------------------------------------------
recursive function eu2om(e) result(res)

IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: e(3)         !< Euler angles in
radians
real(kind=sgl)                  :: res(3,3)     !< output orientation
matrix
        
real(kind=sgl)                  :: c1, c2, c3, s1, s2, s3
integer(kind=irg)               :: i,j
real(kind=sgl),parameter        :: thr = 1.0E-8

c1 = cos(e(1))
c2 = cos(e(2))
c3 = cos(e(3))
s1 = sin(e(1))
s2 = sin(e(2))
s3 = sin(e(3))

res(1,1) = c1*c3-s1*s3*c2
res(1,2) = s1*c3+c1*s3*c2
res(1,3) = s3*s2
res(2,1) = -c1*s3-s1*c3*c2
res(2,2) = -s1*s3+c1*c3*c2
res(2,3) = c3*s2
res(3,1) = s1*s2
res(3,2) = -c1*s2
res(3,3) = c2

do i=1,3
  do j=1,3
    if (abs(res(i,j)).lt.thr) res(i,j) = 0.0
  end do
end do

end function eu2om

!--------------------------------------------------------------------------
!
! Function: eu2om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Euler angles to orientation matrix (double precision)
![Morawiec, page 28]
!
!> @param e 3 Euler angles in radians (double precision)  
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!> @data 7/23/14   MDG 1.1 verified
!--------------------------------------------------------------------------
recursive function eu2om_d(e) result(res)

IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: e(3)         !< Euler angles in
radians
real(kind=dbl)                  :: res(3,3)     !< output orientation
matrix

real(kind=dbl)                  :: c1, c2, c3, s1, s2, s3
integer(kind=irg)               :: i,j
real(kind=dbl),parameter        :: thr = 1.0D-10

c1 = dcos(e(1))
c2 = dcos(e(2))
c3 = dcos(e(3))
s1 = dsin(e(1))
s2 = dsin(e(2))
s3 = dsin(e(3))

res(1,1) = c1*c3-s1*s3*c2
res(1,2) = s1*c3+c1*s3*c2
res(1,3) = s3*s2
res(2,1) = -c1*s3-s1*c3*c2
res(2,2) = -s1*s3+c1*c3*c2
res(2,3) = c3*s2
res(3,1) = s1*s2
res(3,2) = -c1*s2
res(3,3) = c2

do i=1,3
  do j=1,3
    if (dabs(res(i,j)).lt.thr) res(i,j) = 0.D0
  end do
end do

end function eu2om_d

!--------------------------------------------------------------------------
!
! FUNCTION: eu2ax
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert euler to axis angle
!
!> @param e 3 euler angles (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 2.0 explicit implementation
!> @date 7/23/14   MDG 2.1 exception for zero rotation angle
!--------------------------------------------------------------------------
recursive function eu2ax(e) result(res)


real(kind=sgl), INTENT(IN)              :: e(3)
real(kind=sgl)                          :: res(4), t, del, tau, alpha,
sig
real(kind=dbl),parameter                :: thr = 1.0E-6

t = tan(e(2)*0.5)
sig = 0.5*(e(1)+e(3))
del = 0.5*(e(1)-e(3))
tau = sqrt(t*t+sin(sig)**2)

if (sig.eq.sngl(cPi)*0.5) then  ! Infinity 
  alpha = sngl(cPi)
else
  alpha = 2.0 * atan(tau/cos(sig))
end if 

if (abs(alpha).lt.thr) then
! return a default identity axis-angle pair
        res = (/ 0.0, 0.0, 1.0, 0.0 /)
else
! passive axis-angle pair so a minus sign in front
        res(1:3) = - epsijk * (/ t*cos(del), t*sin(del), sin(sig) /) /
tau
        res(4) = alpha
end if

! make sure alpha is positive
if (alpha.lt.0.0) res = -res

end function eu2ax

!--------------------------------------------------------------------------
!
! FUNCTION: eu2ax_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert euler to axis angle
!
!> @param e 3 euler angles (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 1.1 exception for zero rotation angle
!--------------------------------------------------------------------------
recursive function eu2ax_d(e) result(res)


real(kind=dbl), INTENT(IN)              :: e(3)
real(kind=dbl)                          :: res(4), del, t, tau, alpha,
sig
real(kind=dbl),parameter                :: thr = 1.0D-10

t = dtan(e(2)*0.5D0)
sig = 0.5D0*(e(1)+e(3))
del = 0.5D0*(e(1)-e(3))
tau = dsqrt(t*t+dsin(sig)**2)

if (sig.eq.cPi*0.5D0) then  ! Infinity 
  alpha = cPi
else
  alpha = 2.D0 * datan(tau/dcos(sig))
end if 

if (abs(alpha).lt.thr) then
! return a default identity axis-angle pair
        res = (/ 0.D0, 0.D0, 1.D0, 0.D0 /)
else
! passive axis-angle pair so a minus sign in front
        res(1:3) = - epsijkd *(/ t*dcos(del), t*dsin(del), dsin(sig) /)
/ tau
        res(4) = alpha
end if

! make sure alpha is positive
if (alpha.lt.0.D0) res = -res

end function eu2ax_d

!--------------------------------------------------------------------------
!
! Function: eu2ro
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Euler angles to Rodrigues vector (single precision) [Morawiec,
!page 40]
!
!> @param e 3 Euler angles in radians (single precision)  
!>  
!
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function eu2ro(e) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: e(3)         !< input Euler angles
(radians)
real(kind=sgl)                  :: res(4)       !< output Rodrigues
vector

real(kind=sgl)                  :: t
real(kind=sgl),parameter        :: thr = 1.0E-7

! first go to the axis-angle representation
res = eu2ax(e)

! then adjust the fourth component to be tan(omega/2)
t = res(4)
if (abs(t-sngl(cPi)).lt.thr) then
  res(4) = infty
  return
end if
 
if (t.eq.0.0) then 
  res = (/ 0.0, 0.0, 0.0, 0.0 /)
else
  res(4) = tan(t*0.5)
end if

end function eu2ro

!--------------------------------------------------------------------------
!
! Function: eu2ro_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Euler angles to Rodrigues vector (double precision) [Morawiec,
!page 40]
!
!> @param e 3 Euler angles in radians (double precision)  
!>  
!
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function eu2ro_d(e) result(res)


IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: e(3)         !< input Euler angles
(radians)
real(kind=dbl)                  :: res(4)       !< output Rodrigues
vector

real(kind=dbl)                  :: t
real(kind=sgl),parameter        :: thr = 1.0D-10

! first go to the axis-angle representation
res = eu2ax_d(e)

! then adjust the fourth component to be tan(omega/2)
t = res(4)
if (abs(t-cPi).lt.thr) then
  res(4) = infty
  return
end if
 
if (t.eq.0.D0) then 
  res = (/ 0.D0, 0.D0, 0.D0, 0.D0 /)
else
  res(4) = dtan(t*0.5D0)
end if

end function eu2ro_d

!--------------------------------------------------------------------------
!
! Function: eu2qu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Euler angles to quaternion (single precision) [Morawiec, page
!40]
!
!> @note verified 8/5/13
!
!> @param e 3 Euler angles in radians (single precision)  
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!> @date 8/07/14   MDG 1.1 verified
!--------------------------------------------------------------------------
recursive function eu2qu(e) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: e(3)         !< input Euler angles in
radians
real(kind=sgl)                  :: res(4)       !< output quaternion
        
real(kind=sgl)                  :: ee(3), cPhi, cp, cm, sPhi, sp, sm

ee = 0.5*e

cPhi = cos(ee(2))
sPhi = sin(ee(2))
cm = cos(ee(1)-ee(3))
sm = sin(ee(1)-ee(3))
cp = cos(ee(1)+ee(3))
sp = sin(ee(1)+ee(3))

! passive quaternion
res = (/ cPhi*cp, -epsijk*sPhi*cm, -epsijk*sPhi*sm, -epsijk*cPhi*sp /)

! first component must be positive
if (res(1).lt.0.0) res = -res

end function eu2qu

!--------------------------------------------------------------------------
!
! Function: eu2qu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Euler angles to quaternion (double precision) [Morawiec, page
!40]
!
!> @note verified 8/5/13
!
!> @param e 3 Euler angles in radians (double precision)  
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!> @date 8/07/14   MDG 1.1 verified
!--------------------------------------------------------------------------
recursive function eu2qu_d(e) result(res)


IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: e(3)         !< input Euler angles in
radians
real(kind=dbl)                  :: res(4)       !< output quaternion

real(kind=dbl)                  :: ee(3), cPhi, cp, cm, sPhi, sp, sm

ee = 0.5D0*e

cPhi = dcos(ee(2))
sPhi = dsin(ee(2))
cm = dcos(ee(1)-ee(3))
sm = dsin(ee(1)-ee(3))
cp = dcos(ee(1)+ee(3))
sp = dsin(ee(1)+ee(3))

! passive quaternion
res = (/ cPhi*cp, -epsijkd*sPhi*cm, -epsijkd*sPhi*sm, -epsijkd*cPhi*sp
/)

! first component must be positive
if (res(1).lt.0.D0) res = -res

end function eu2qu_d

!--------------------------------------------------------------------------
!
! Function: om2eu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief orientation matrix to euler angles (single precision)
!
!> @note verified 8/19/14 using Mathematica
!
!> @param o orientation matrix (single precision)  
!
!> @date 8/04/13   MDG 1.0 original
!> @date 8/19/14   MDG 1.1 verification using Mathematica
!--------------------------------------------------------------------------
recursive function om2eu(o) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: o(3,3)               !< orientation
matrix
real(kind=sgl)                  :: res(3), zeta

if (abs(o(3,3)).ne.1.0) then
        res(2) = acos(o(3,3))
        zeta = 1.0/sqrt(1.0-o(3,3)**2)
        res(1) = atan2(o(3,1)*zeta,-o(3,2)*zeta)
        res(3) = atan2(o(1,3)*zeta, o(2,3)*zeta)
else
! we arbitrarily assign the entire angle to phi_1
        if (o(3,3).eq.1.0) then
                res(1) = atan2( o(1,2),o(1,1))
                res(2) = 0.0
                res(3) = 0.0
        else
                res(1) =-atan2(-o(1,2),o(1,1))
                res(2) = sngl(cPi)
                res(3) = 0.0
        end if
end if

! reduce Euler angles to definition ranges (and positive values only)
if (res(1).lt.0.0) res(1) = mod(res(1)+100.0*sngl(cPi),2.0*sngl(cPi))
if (res(2).lt.0.0) res(2) = mod(res(2)+100.0*sngl(cPi),sngl(cPi))
if (res(3).lt.0.0) res(3) = mod(res(3)+100.0*sngl(cPi),2.0*sngl(cPi))

end function om2eu

!--------------------------------------------------------------------------
!
! Function: om2eu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief orientation matrix to euler angles (double precision)
!
!> @note verified 8/19/14 using Mathematica
!
!> @param o orientation matrix (double precision)  
!
!> @date 8/04/13   MDG 1.0 original
!> @date 8/19/14   MDG 1.1 verification using Mathematica
!--------------------------------------------------------------------------
recursive function om2eu_d(o) result(res)


IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: o(3,3)               !< orientation
matrix
real(kind=dbl)                  :: res(3), zeta
real(kind=dbl),parameter        :: thr = 1.0D-8

if (abs((abs(o(3,3))-1.D0)).gt.thr) then
        res(2) = dacos(o(3,3))
        zeta = 1.D0/dsqrt(1.D0-o(3,3)**2)
        res(1) = datan2(o(3,1)*zeta,-o(3,2)*zeta)
        res(3) = datan2(o(1,3)*zeta, o(2,3)*zeta)
else
! we arbitrarily assign the entire angle to phi_1
        if (abs(o(3,3)-1.D0).lt.thr) then
                res(1) = datan2( o(1,2),o(1,1))
                res(2) = 0.D0
                res(3) = 0.D0
        else
                res(1) =-datan2(-o(1,2),o(1,1))
                res(2) = cPi
                res(3) = 0.D0
        end if
end if

! reduce Euler angles to definition ranges (and positive values only)
if (res(1).lt.0.D0) res(1) = dmod(res(1)+100.D0*cPi,2.D0*cPi)
if (res(2).lt.0.D0) res(2) = dmod(res(2)+100.D0*cPi,cPi)
if (res(3).lt.0.D0) res(3) = dmod(res(3)+100.D0*cPi,2.D0*cPi)

end function om2eu_d

!--------------------------------------------------------------------------
!
! Function: ax2om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Axis angle pair to orientation matrix (single precision)
!
!> @note verified 8/5/13.
!
!> @param a axis angle pair (single precision)  
!>  
!
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ax2om(a) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: a(4)         !< axis angle pair
real(kind=sgl)                  :: res(3,3)

real(kind=sgl)                  :: q, c, s, omc
integer(kind=irg)               :: i

c = cos(a(4))
s = sin(a(4))
omc = 1.0-c

do i=1,3
  res(i,i) = a(i)**2*omc + c
end do

q = omc*a(1)*a(2)
res(1,2) = q + s*a(3)
res(2,1) = q - s*a(3)

q = omc*a(2)*a(3)
res(2,3) = q + s*a(1)
res(3,2) = q - s*a(1)

q = omc*a(3)*a(1)
res(3,1) = q + s*a(2)
res(1,3) = q - s*a(2)

if (epsijk.eq.1.0) res = transpose(res)

end function ax2om

!--------------------------------------------------------------------------
!
! Function: ax2om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Axis angle pair to orientation matrix (double precision)
!
!> @note verified 8/5/13.
!
!> @param a axis angle pair (double precision)  
!>  
!
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ax2om_d(a) result(res)


IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: a(4)         !< axis angle pair
real(kind=dbl)                  :: res(3,3)
        
real(kind=dbl)                  :: q, c, s, omc
integer(kind=irg)               :: i

c = dcos(a(4))
s = dsin(a(4))
omc = 1.D0-c

do i=1,3
  res(i,i) = a(i)**2*omc + c
end do


q = omc*a(1)*a(2)
res(1,2) = q + s*a(3)
res(2,1) = q - s*a(3)

q = omc*a(2)*a(3)
res(2,3) = q + s*a(1)
res(3,2) = q - s*a(1)

q = omc*a(3)*a(1)
res(3,1) = q + s*a(2)
res(1,3) = q - s*a(2)

if (epsijkd.eq.1.D0) res = transpose(res)

end function ax2om_d

!--------------------------------------------------------------------------
!
! Function: qu2eu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Quaternion to Euler angles (single precision) [Morawiec page
!40, with errata !!!! ]
!
!> @param q quaternion (single precision)  
!>  
!
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function qu2eu(q) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: q(4)         !< quaternion
real(kind=sgl)                  :: res(3)

real(kind=sgl)                  :: qq(4), q12, q03, chi, Phi, phi1, phi2

qq = q

q03 = qq(1)**2+qq(4)**2
q12 = qq(2)**2+qq(3)**2
chi = sqrt(q03*q12)

if (chi.eq.0.0) then
  if (q12.eq.0.0) then 
   if (epsijk.eq.1.0) then
    Phi = 0.0
    phi2 = 0.0                  ! arbitrarily due to degeneracy
    phi1 = atan2(-2.0*qq(1)*qq(4),qq(1)**2-qq(4)**2)
   else
    Phi = 0.0
    phi2 = 0.0                  ! arbitrarily due to degeneracy
    phi1 = atan2( 2.0*qq(1)*qq(4),qq(1)**2-qq(4)**2)
   end if
  else
   if (epsijk.eq.1.0) then
    Phi = sngl(cPi)
    phi2 = 0.0                  ! arbitrarily due to degeneracy
    phi1 = atan2(2.0*qq(2)*qq(3),qq(2)**2-qq(3)**2)
   else
    Phi = sngl(cPi)
    phi2 = 0.0                  ! arbitrarily due to degeneracy
    phi1 = atan2(2.0*qq(2)*qq(3),qq(2)**2-qq(3)**2)
   end if
  end if
else            ! this is not a special degenerate case
  if (epsijk.eq.1.0) then
    Phi = atan2( 2.0*chi, q03-q12 )
    chi = 1.0/chi
    phi1 = atan2( (-qq(1)*qq(3)+qq(2)*qq(4))*chi,
(-qq(1)*qq(2)-qq(3)*qq(4))*chi )
    phi2 = atan2( (qq(1)*qq(3)+qq(2)*qq(4))*chi,
(-qq(1)*qq(2)+qq(3)*qq(4))*chi )
  else
    Phi = atan2( 2.0*chi, q03-q12 )
    chi = 1.0/chi
    phi1 = atan2( (qq(1)*qq(3)+qq(2)*qq(4))*chi,
(qq(1)*qq(2)-qq(3)*qq(4))*chi )
    phi2 = atan2( (-qq(1)*qq(3)+qq(2)*qq(4))*chi,
(qq(1)*qq(2)+qq(3)*qq(4))*chi )
  end if
end if

res = (/ phi1, Phi, phi2 /)

end function qu2eu

!--------------------------------------------------------------------------
!
! Function: qu2eu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Quaternion to Euler angles (double precision) [Morawiec page
!40, with errata !!!! ]
!
!> @param q quaternion (double precision)  
!>  
!
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function qu2eu_d(q) result(res)


IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: q(4)         !< quaternion
real(kind=dbl)                  :: res(3)
        
real(kind=dbl)                  :: qq(4), q12, q03, chi, Phi, phi1, phi2

qq = q

q03 = qq(1)**2+qq(4)**2
q12 = qq(2)**2+qq(3)**2
chi = dsqrt(q03*q12)

if (chi.eq.0.D0) then
  if (q12.eq.0.D0) then 
   if (epsijkd.eq.1.D0) then 
    Phi = 0.D0
    phi2 = 0.D0                 ! arbitrarily due to degeneracy
    phi1 = datan2(-2.D0*qq(1)*qq(4),qq(1)**2-qq(4)**2)
   else
    Phi = 0.D0
    phi2 = 0.D0                 ! arbitrarily due to degeneracy
    phi1 = datan2( 2.D0*qq(1)*qq(4),qq(1)**2-qq(4)**2)
   end if
  else
   if (epsijkd.eq.1.D0) then 
    Phi = cPi
    phi2 = 0.D0                 ! arbitrarily due to degeneracy
    phi1 = datan2(2.D0*qq(2)*qq(3),qq(2)**2-qq(3)**2)
   else
    Phi = cPi
    phi2 = 0.D0                 ! arbitrarily due to degeneracy
    phi1 = datan2(2.D0*qq(2)*qq(3),qq(2)**2-qq(3)**2)
   end if
  end if
else            ! this is not a special degenerate case
  if (epsijkd.eq.1.D0) then 
    Phi = datan2( 2.D0*chi, q03-q12 )
    chi = 1.D0/chi
    phi1 = datan2( (-qq(1)*qq(3)+qq(2)*qq(4))*chi,
(-qq(1)*qq(2)-qq(3)*qq(4))*chi )
    phi2 = datan2( (qq(1)*qq(3)+qq(2)*qq(4))*chi,
(-qq(1)*qq(2)+qq(3)*qq(4))*chi )
  else
    Phi = datan2( 2.D0*chi, q03-q12 )
    chi = 1.D0/chi
    phi1 = datan2( (qq(1)*qq(3)+qq(2)*qq(4))*chi,
(qq(1)*qq(2)-qq(3)*qq(4))*chi )
    phi2 = datan2( (-qq(1)*qq(3)+qq(2)*qq(4))*chi,
(qq(1)*qq(2)+qq(3)*qq(4))*chi )
  end if
end if

res = (/ phi1, Phi, phi2 /)

end function qu2eu_d



!--------------------------------------------------------------------------
!
! Function: ax2ho
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Axis angle pair to homochoric (single precision)
!
!> @param a axis-angle pair (single precision)  
!>  
! !
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ax2ho(a) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: a(4)         !< axis angle pair
real(kind=sgl)                  :: res(3)
        
real(kind=sgl)                  :: f

! a(4) must be in [0,pi] !

f = 0.75 * ( a(4) - sin(a(4)) )
f = f**(1.0/3.0)

res = a(1:3) * f

end function ax2ho

!--------------------------------------------------------------------------
!
! Function: ax2ho_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Axis angle pair to homochoric (double precision)
!
!> @param a axis-angle pair (double precision)  
!>  
! !
!> @date 8/04/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ax2ho_d(a) result(res)

IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: a(4)         !< axis angle pair
real(kind=dbl)                  :: res(3)

real(kind=dbl)                  :: f

! a(4) must be in [0,pi] !

f = 0.75D0 * ( a(4) - dsin(a(4)) )
f = f**(1.D0/3.D0)

res = a(1:3) * f

end function ax2ho_d

!--------------------------------------------------------------------------
!
! Function: ho2ax
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Homochoric to axis angle pair (single precision)
!
!> @param h homochoric coordinates (single precision)  
!>  
! 
!
!> @date 8/04/13  MDG 1.0 original
!> @date 07/21/14 MDG 1.1 double precision fit coefficients
!--------------------------------------------------------------------------
recursive function ho2ax(h) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: h(3)         !< homochoric
coordinates
real(kind=sgl)                  :: res(4)

integer(kind=irg)               :: i
real(kind=sgl)                  :: hn(3), hmag, s, hm
real(kind=sgl),parameter        :: thr = 1.0E-6

! normalize h and store the magnitude
hmag = sum(h*h)
if (hmag.eq.0.0) then
  res = (/ 0.0, 0.0, 1.0, 0.0 /)
else
  hm = hmag
  hn = h/sqrt(hmag)

! convert the magnitude to the rotation angle
  s = LPs%tfit(1) + LPs%tfit(2) * hmag
  do i=3,16
    hm = hm*hmag
    s = s + LPS%tfit(i) * hm
  end do

  s = 2.0*acos(s)
  if (abs(s-sngl(cPi)).lt.thr) then 
   res = (/ hn(1), hn(2), hn(3), sngl(cPi) /)
  else
   res = (/ hn(1), hn(2), hn(3), s /)
  end if
end if

end function ho2ax

!--------------------------------------------------------------------------
!
! Function: ho2ax_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Homochoric to axis angle pair (double precision)
!
!> @param h homochoric coordinates (double precision)  
!>  
!
!> @date 8/04/13   MDG 1.0 original
!> @date 07/21/14 MDG 1.1 double precision fit coefficients
!--------------------------------------------------------------------------
recursive function ho2ax_d(h) result(res)


IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: h(3)         !< homochoric
coordinates
real(kind=dbl)                  :: res(4)

integer(kind=irg)               :: i
real(kind=dbl)                  :: hn(3), hmag, s, hm
real(kind=dbl),parameter        :: thr = 1.0E-8

! normalize h and store the magnitude
hmag = sum(h*h)
if (hmag.eq.0.D0) then
  res = (/ 0.D0, 0.D0, 1.D0, 0.D0 /)
else
  hm = hmag
  hn = h/dsqrt(hmag)

! convert the magnitude to the rotation angle
  s = LPs%tfit(1) + LPs%tfit(2) * hmag
  do i=3,16
    hm = hm*hmag
    s = s + LPS%tfit(i) * hm
  end do

  s = 2.D0*dacos(s)
  if (dabs(s-cPi).lt.thr) then 
   res = (/ hn(1), hn(2), hn(3), cPi /)
  else
   res = (/ hn(1), hn(2), hn(3), s /)
  end if
end if

end function ho2ax_d

!--------------------------------------------------------------------------
!
! FUNCTION: om2ax
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert orientation matrix to axis angle
!
!> @details this assumes that the matrix represents a passive rotation.
!
!> @param om 3x3 orientation matrix (single precision)
!>  
! 
!> @date 8/12/13  MDG 1.0 original
!> @date 07/08/14 MDG 2.0 replaced by direct solution
!--------------------------------------------------------------------------
recursive function om2ax(om) result(res)

 
real(kind=sgl), INTENT(IN)              :: om(3,3)
real(kind=sgl)                          :: res(4)

real(kind=sgl)                          :: t, omega, qq(4), o(3,3)
real(kind=sgl)                          :: VL(3,3), VR(3,3), Wr(3),
Wi(3), WORK(10)
complex(kind=sgl)                       :: ev
complex(kind=sgl),parameter             :: cone = cmplx(1.0,0.0)
real(kind=sgl),parameter                :: thr = 1.0E-7
integer(kind=irg)                       :: nn, LDA, LDVL, LDVR, INFO,
LWORK
character(1)                            :: JOBVL, JOBVR

 o = om

! first get the rotation angle
 t = 0.50*(om(1,1)+om(2,2)+om(3,3) - 1.0)
 if (t.gt.1.0) t = 1.0
 if (t.lt.-1.0) t = -1.0
 res(4) = acos(t)

if (res(4).eq.0.0) then
  res(1:3) = (/ 0.0, 0.0, 1.0 /)
  return
else
! set some initial LAPACK variables 
 nn = 3
 LDA = nn
 LDVL = nn
 LDVR = nn
 INFO = 0
 
! first initialize the parameters for the LAPACK DGEEV routines
 JOBVL = 'N'   ! do not compute the left eigenvectors
 JOBVR = 'V'   ! do compute the right eigenvectors
 LWORK = 20   

!     SUBROUTINE SGEEV( JOBVL, JOBVR, N, A, LDA, WR, WI, VL, LDVL, VR,
!    $                  LDVR, WORK, LWORK, INFO )

! call the eigenvalue solver
  call sgeev(JOBVL,JOBVR,nn,o,LDA,Wr,Wi,VL,LDVL,VR,LDVR,WORK,LWORK,INFO)
  if (INFO.ne.0) write (*,*) 'Error in om2ax/sgeev : SGEEV return not
zero'

! next, find the eigenvalue complex(1,0)
  do i=1,3 
    ev = cmplx(Wr(i),Wi(i))
    if (abs(ev-cone).lt.thr) then
      res(1:3) = VR(1:3,i)
      if ((om(2,3)-om(3,2)).ne.0.D0) res(1) =
sign(res(1),-epsijk*(om(2,3)-om(3,2)))
      if ((om(3,1)-om(1,3)).ne.0.D0) res(2) =
sign(res(2),-epsijk*(om(3,1)-om(1,3)))
      if ((om(1,2)-om(2,1)).ne.0.D0) res(3) =
sign(res(3),-epsijk*(om(1,2)-om(2,1)))
      return
    end if
  end do
end if

end function om2ax

!--------------------------------------------------------------------------
!
! FUNCTION: om2ax_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert orientation matrix to axis angle
!
!> @param om 3x3 orientation matrix (double precision)
!>  
! 
!> @date 8/12/13  MDG 1.0 original
!> @date 07/08/14 MDG 2.0 replaced by direct solution
!> @date 08/20/14 MDG 3.0 replaced by eigenvalue-based method
!--------------------------------------------------------------------------
recursive function om2ax_d(om) result(res)

real(kind=dbl), INTENT(IN)              :: om(3,3)
real(kind=dbl)                          :: res(4)

real(kind=dbl)                          :: t, omega, qq(4), o(3,3)
real(kind=dbl)                          :: VL(3,3), VR(3,3), Wr(3),
Wi(3), WORK(10)
complex(kind=dbl)                       :: ev
complex(kind=dbl),parameter             :: cone = cmplx(1.D0,0.D0)
real(kind=dbl),parameter                :: thr = 1.0D-10
integer(kind=irg)                       :: nn, LDA, LDVL, LDVR, INFO,
LWORK
character(1)                            :: JOBVL, JOBVR

 o = om

! first get the rotation angle
 t = 0.5D0*(om(1,1)+om(2,2)+om(3,3) - 1.D0)
 if (t.gt.1.D0) t = 1.D0
 if (t.lt.-1.D0) t = -1.D0
 res(4) = dacos(t)

if (res(4).eq.0.D0) then
  res(1:3) = (/ 0.D0, 0.D0, 1.D0 /)
  return
else
! set some initial LAPACK variables 
 nn = 3
 LDA = nn
 LDVL = nn
 LDVR = nn
 INFO = 0
 
! first initialize the parameters for the LAPACK DGEEV routines
 JOBVL = 'N'   ! do not compute the left eigenvectors
 JOBVR = 'V'   ! do compute the right eigenvectors
 LWORK = 20   

!     SUBROUTINE DGEEV( JOBVL, JOBVR, N, A, LDA, WR, WI, VL, LDVL, VR,
!    $                  LDVR, WORK, LWORK, INFO )

! call the eigenvalue solver
  call dgeev(JOBVL,JOBVR,nn,o,LDA,Wr,Wi,VL,LDVL,VR,LDVR,WORK,LWORK,INFO)
  if (INFO.ne.0) write (*,*) 'Error in om2ax/dgeev : DGEEV return not
zero'

! next, find the eigenvalue complex(1,0)
 do i=1,3 
    if ((abs(Wr(i)-1.D0).lt.thr).and.(abs(Wi(i)).lt.thr)) then
      res(1:3) = VR(1:3,i)
      if ((om(2,3)-om(3,2)).ne.0.D0) res(1) =
dsign(res(1),-epsijkd*(om(2,3)-om(3,2)))
      if ((om(3,1)-om(1,3)).ne.0.D0) res(2) =
dsign(res(2),-epsijkd*(om(3,1)-om(1,3)))
      if ((om(1,2)-om(2,1)).ne.0.D0) res(3) =
dsign(res(3),-epsijkd*(om(1,2)-om(2,1)))
      return
    end if
  end do
end if

end function om2ax_d

!--------------------------------------------------------------------------
!
! Function: ro2ax
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Rodrigues vector to axis angle pair (single precision)
!
!> @param r Rodrigues vector (single precision)  
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!> @date 8/11/14   MDG 1.1 added infty handling
!--------------------------------------------------------------------------
recursive function ro2ax(r) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: r(4)         !< input Rodrigues
vector
real(kind=sgl)                  :: res(4)       !< output axis-angle
pair

real(kind=sgl)                  :: ta, angle

ta = r(4)

if (ta.eq.0.0) then 
  res = (/ 0.0, 0.0, 1.0, 0.0 /)
  return
end if

if (ta.eq.infty) then
  res = (/ r(1), r(2), r(3), sngl(cPi) /)
else
  angle = 2.0*atan(ta)
  ta = 1.0/sqrt(sum(r(1:3)*r(1:3)))
  res = (/ r(1)/ta, r(2)/ta, r(3)/ta, angle /)
end if

end function ro2ax

!--------------------------------------------------------------------------
!
! Function: ro2ax_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Rodrigues vector to axis angle pair (double precision)
!
!> @param r Rodrigues vector (double precision)  
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!> @date 8/11/14   MDG 1.1 added infty handling
!--------------------------------------------------------------------------
recursive function ro2ax_d(r) result(res)


IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: r(4)         !< input Rodrigues
vector
real(kind=dbl)                  :: res(4)       !< output axis-angle
pair

real(kind=dbl)                  :: ta, angle

ta = r(4)

if (ta.eq.0.D0) then 
  res = (/ 0.D0, 0.D0, 1.D0, 0.D0 /)
  return
end if

if (ta.eq.infty) then
  res = (/ r(1), r(2), r(3), cPi /)
else
  angle = 2.D0*datan(ta)
  ta = 1.D0/dsqrt(sum(r(1:3)*r(1:3)))
  res = (/ r(1)/ta, r(2)/ta, r(3)/ta, angle /)
end if

end function ro2ax_d


!--------------------------------------------------------------------------
!
! FUNCTION: ax2ro
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert axis angle to Rodrigues
!
!> @param a axis angle pair (single precision)
!>  
! 
!> @date 8/12/13 MDG 1.0 original
!> @date 7/6/14  MDG 2.0 simplified
!> @date 8/11/14 MDG 2.1 added infty handling
!--------------------------------------------------------------------------
recursive function ax2ro(a) result(res)


real(kind=sgl), INTENT(IN)              :: a(4)
real(kind=sgl)                          :: res(4)

real(kind=sgl)                          :: t
real(kind=sgl),parameter                :: thr = 1.0E-7

if (a(4).eq.0.0) then
  res = (/ 0.0, 0.0, 0.0, 0.0 /)
  return
end if

res(1:3) =  a(1:3)

! we need to deal with the 180 degree case
if (abs(a(4)-sngl(cPi)).lt.thr) then
  res(4) = infty
else
  res(4) = tan( a(4) * 0.5 )
end if

end function ax2ro

!--------------------------------------------------------------------------
!
! FUNCTION: ax2ro_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert axis angle to Rodrigues
!
!> @param a axis angle pair (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/6/14  MDG 2.0 simplified
!> @date 8/11/14 MDG 2.1 added infty handling
!--------------------------------------------------------------------------
recursive function ax2ro_d(a) result(res)


real(kind=dbl), INTENT(IN)              :: a(4)
real(kind=dbl)                          :: res(4)

real(kind=sgl)                          :: t
real(kind=sgl),parameter                :: thr = 1.0E-7

if (a(4).eq.0.D0) then
  res = (/ 0.D0, 0.D0, 0.D0, 0.D0 /)
  return
end if

res(1:3) =  a(1:3)

! we need to deal with the 180 degree case
if (dabs(a(4)-cPi).lt.thr) then
  res(4) = infty
else
  res(4) = dtan( a(4) * 0.5D0 )
end if

end function ax2ro_d



!--------------------------------------------------------------------------
!
! FUNCTION: ax2qu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert axis angle to quaternion
!
!> @param a axis angle pair (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 1.1 explicit transformation
!--------------------------------------------------------------------------
recursive function ax2qu(a) result(res)

real(kind=sgl), INTENT(IN)              :: a(4)
real(kind=sgl)                          :: res(4), c, s


if (a(4).eq.0.0) then
        res = (/ 1.0, 0.0, 0.0, 0.0 /)
else
        c = cos(a(4)*0.5)
        s = sin(a(4)*0.5)
        res = (/ c, a(1)*s, a(2)*s, a(3)*s /)
end if

end function ax2qu

!--------------------------------------------------------------------------
!
! FUNCTION: ax2qu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert axis angle to quaternion
!
!> @param a axis angle pair (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 1.1 explicit transformation
!--------------------------------------------------------------------------
recursive function ax2qu_d(a) result(res)

real(kind=dbl), INTENT(IN)              :: a(4)
real(kind=dbl)                          :: res(4), c, s


if (a(4).eq.0.D0) then
        res = (/ 1.D0, 0.D0, 0.D0, 0.D0 /)
else
        c = dcos(a(4)*0.5D0)
        s = dsin(a(4)*0.5D0)
        res = (/ c, a(1)*s, a(2)*s, a(3)*s /)
end if

end function ax2qu_d



!--------------------------------------------------------------------------
!
! FUNCTION: ro2ho
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert rodrigues to homochoric
!
!> @param r Rodrigues vector (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/24/14   MDG 2.0 explicit transformation
!> @date 8/11/14   MDG 3.0 added infty handling
!--------------------------------------------------------------------------
recursive function ro2ho(r) result(res)


real(kind=sgl), INTENT(IN)              :: r(4)
real(kind=sgl)                          :: res(3), rv, f, omega

rv = sum(r(1:3)*r(1:3))
if (rv.eq.0.0) then
        res = (/ 0.0, 0.0, 0.0 /)
        return
end if

if (r(4).eq.infty) then
        f = 0.750 * sngl(cPi)
else
        omega = 2.0*atan(r(4))
        f = 0.750*(omega - sin(omega))
end if

res(1:3) = r(1:3) * f**0.333333333

end function ro2ho

!--------------------------------------------------------------------------
!
! FUNCTION: ro2ho_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert rodrigues to homochoric
!
!> @param r Rodrigues vector (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/24/14   MDG 2.0 explicit transformation
!--------------------------------------------------------------------------
recursive function ro2ho_d(r) result(res)


real(kind=dbl), INTENT(IN)              :: r(4)
real(kind=dbl)                          :: res(3), rv, f, omega

rv = sum(r(1:3)*r(1:3))
if (rv.eq.0.D0) then
        res = (/ 0.D0, 0.D0, 0.D0 /)
        return
end if

if (r(4).eq.infty) then
        f = 0.75D0 * cPi
else
        omega = 2.D0*datan(r(4))
        f = 0.75D0*(omega - dsin(omega))
end if

res(1:3) = r(1:3) * f**0.333333333D0

end function ro2ho_d



!--------------------------------------------------------------------------
!
! FUNCTION: qu2om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a quaternion to a 3x3 matrix
!
!> @param q quaternion (single precision)  
!>  
! 
!> @note verified 8/5/13
!
!> @date 6/03/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function qu2om(q) result(res)


real(kind=sgl),INTENT(IN)               :: q(4)
real(kind=sgl)                          :: res(3,3)

real(kind=sgl)                          :: qq, qc(4)

qq=q(1)*q(1)-(q(2)*q(2)+q(3)*q(3)+q(4)*q(4))

qc = q

res(1,1) = qq+2.0*qc(2)*qc(2)
res(2,2) = qq+2.0*qc(3)*qc(3)
res(3,3) = qq+2.0*qc(4)*qc(4)

res(1,2) = 2.0*(qc(2)*qc(3)-qc(1)*qc(4))
res(2,3) = 2.0*(qc(3)*qc(4)-qc(1)*qc(2))
res(3,1) = 2.0*(qc(4)*qc(2)-qc(1)*qc(3))
res(2,1) = 2.0*(qc(3)*qc(2)+qc(1)*qc(4))
res(3,2) = 2.0*(qc(4)*qc(3)+qc(1)*qc(2))
res(1,3) = 2.0*(qc(2)*qc(4)+qc(1)*qc(3))

if (epsijk.ne.1.0) res = transpose(res)

end function qu2om


!--------------------------------------------------------------------------
!
! FUNCTION: qu2om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a quaternion to a 3x3 matrix (double precision)
!
!> @param q quaternion (double precision)  
!>  
! 
!> @note verified 8/5/13
!
!> @date 6/03/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function qu2om_d(q) result(res)


real(kind=dbl),INTENT(IN)               :: q(4)
real(kind=dbl)                          :: res(3,3)

real(kind=dbl)                          :: qq, qc(4)

qq=q(1)*q(1)-(q(2)*q(2)+q(3)*q(3)+q(4)*q(4))

qc = q

res(1,1) = qq+2.D0*qc(2)*qc(2)
res(2,2) = qq+2.D0*qc(3)*qc(3)
res(3,3) = qq+2.D0*qc(4)*qc(4)

res(1,2) = 2.D0*(qc(2)*qc(3)-qc(1)*qc(4))
res(2,3) = 2.D0*(qc(3)*qc(4)-qc(1)*qc(2))
res(3,1) = 2.D0*(qc(4)*qc(2)-qc(1)*qc(3))
res(2,1) = 2.D0*(qc(3)*qc(2)+qc(1)*qc(4))
res(3,2) = 2.D0*(qc(4)*qc(3)+qc(1)*qc(2))
res(1,3) = 2.D0*(qc(2)*qc(4)+qc(1)*qc(3))

if (epsijkd.ne.1.D0) res = transpose(res)

end function qu2om_d


!--------------------------------------------------------------------------
!
! FUNCTION: om2qu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a 3x3 rotation matrix to a unit quaternion (see
!Morawiec, page 37)
!
!> @param x 3x3 matrix to be converted (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 8/18/14   MDG 2.0 new version
!--------------------------------------------------------------------------
recursive function om2qu(x) result(res)


real(kind=sgl), INTENT(IN)              :: x(3,3)               !< input
matrix
real(kind=sgl)                          :: res(4)

real(kind=sgl)                          :: s, s1, s2, s3, oax(4)

s = x(1,1) + x(2,2) + x(3,3) + 1.0
if (abs(s).lt.thr) s = 0.0
s = sqrt(s)

s1 = x(1,1) - x(2,2) - x(3,3) + 1.0
if (abs(s1).lt.thr) s1 = 0.0
s1 = sqrt(s1)

s2 = -x(1,1) + x(2,2) - x(3,3) + 1.0
if (abs(s2).lt.thr) s2 = 0.0
s2 = sqrt(s2)

s3 = -x(1,1) - x(2,2) + x(3,3) + 1.0
if (abs(s3).lt.thr) s3 = 0.0
s3 = sqrt(s3)

res = (/ s, s1, s2, s3 /) * 0.5

! verify the signs (q0 always positive)
if (x(3,2).lt.x(2,3)) res(2) = -epsijk * res(2)
if (x(1,3).lt.x(3,1)) res(3) = -epsijk * res(3)
if (x(2,1).lt.x(1,2)) res(4) = -epsijk * res(4)

! normalize
s = sqrt(sum(res*res))
if (s.ne.0.0) res = res/s

! we need to do a quick test here to make sure that the 
! sign of the vector part is the same as that of the 
! corresponding vector in the axis-angle representation;
! these two can end up being different, presumably due to rounding 
! issues, but this needs to be further analyzed...
! This adds a little bit of computation overhead but for now it
! is the easiest way to make sure the signs are correct.
oax = om2ax(x)
if (oax(1)*res(2).lt.0.0) res(2) = -res(2)
if (oax(2)*res(3).lt.0.0) res(3) = -res(3)
if (oax(3)*res(4).lt.0.0) res(4) = -res(4)

end function om2qu

!--------------------------------------------------------------------------
!
! FUNCTION: om2qu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert a 3x3 rotation matrix to a unit quaternion (see
!Morawiec, page 37)
!
!> @param x 3x3 matrix to be converted (double precision)
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 8/18/14   MDG 2.0 new version
!--------------------------------------------------------------------------
recursive function om2qu_d(x) result(res)

 
real(kind=dbl), INTENT(IN)              :: x(3,3)               !< input
matrix
real(kind=dbl)                          :: res(4)

real(kind=dbl)                          :: s, s1, s2, s3, oax(4)
real(kind=dbl),parameter                :: thr = 1.0D-10

s = x(1,1) + x(2,2) + x(3,3) + 1.D0
if (abs(s).lt.thr) s = 0.D0
s = dsqrt(s)

s1 = x(1,1) - x(2,2) - x(3,3) + 1.D0
if (abs(s1).lt.thr) s1 = 0.D0
s1 = dsqrt(s1)

s2 = -x(1,1) + x(2,2) - x(3,3) + 1.D0
if (abs(s2).lt.thr) s2 = 0.D0
s2 = dsqrt(s2)

s3 = -x(1,1) - x(2,2) + x(3,3) + 1.D0
if (abs(s3).lt.thr) s3 = 0.D0
s3 = dsqrt(s3)

res = (/ s, s1, s2, s3 /) * 0.5

! verify the signs (q0 always positive)
if (epsijkd.eq.1.D0) then
  if (x(3,2).lt.x(2,3)) res(2) = -res(2)
  if (x(1,3).lt.x(3,1)) res(3) = -res(3)
  if (x(2,1).lt.x(1,2)) res(4) = -res(4)
end if

! normalize
s = dsqrt(sum(res*res))
if (s.ne.0.D0) res = res/s

! we need to do a quick test here to make sure that the 
! sign of the vector part is the same as that of the 
! corresponding vector in the axis-angle representation;
! these two can end up being different, presumably due to rounding 
! issues, but this needs to be further analyzed...
! This adds a little bit of computation overhead but for now it
! is the easiest way to make sure the signs are correct.
oax = om2ax(x)
if (oax(1)*res(2).lt.0.D0) res(2) = -res(2)
if (oax(2)*res(3).lt.0.D0) res(3) = -res(3)
if (oax(3)*res(4).lt.0.D0) res(4) = -res(4)

end function om2qu_d


!--------------------------------------------------------------------------
!
! FUNCTION: qu2ax
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert quaternion to axis angle
!
!> @param q quaternion (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 2.0 explicit transformation
!--------------------------------------------------------------------------
recursive function qu2ax(q) result(res)


real(kind=sgl), INTENT(IN)              :: q(4)
real(kind=sgl)                          :: res(4), omega, s

omega = 2.0 * acos(q(1))
! if the angle equals zero, then we return the rotation axis as [001]
if (omega.eq.0.0) then
  res = (/ 0.0, 0.0, 1.0, 0.0 /)
else
  if (q(1).ne.0.0) then
    s =  (q(1)/abs(q(1)))/sqrt(q(2)**2+q(3)**2+q(4)**2)
    res = (/ q(2)*s, q(3)*s, q(4)*s, omega /)
  else
    res = (/ q(2), q(3), q(4), sngl(cPi) /)
  end if
end if

end function qu2ax

!--------------------------------------------------------------------------
!
! FUNCTION: qu2ax_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert quaternion to axis angle
!
!> @param q quaternion (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 2.0 explicit transformation
!--------------------------------------------------------------------------
recursive function qu2ax_d(q) result(res)


real(kind=dbl), INTENT(IN)              :: q(4)
real(kind=dbl)                          :: res(4), omega, s

omega = 2.D0 * dacos(q(1))
! if the angle equals zero, then we return the rotation axis as [001]
if (omega.eq.0.D0) then
  res = (/ 0.D0, 0.D0, 1.D0, 0.D0 /)
else
  if (q(1).ne.0.D0) then
    s =  (q(1)/abs(q(1)))/dsqrt(q(2)**2+q(3)**2+q(4)**2)
    res = (/ q(2)*s, q(3)*s, q(4)*s, omega /)
  else
    res = (/ q(2), q(3), q(4), cPi /)
  end if
end if

end function qu2ax_d


!--------------------------------------------------------------------------
!
! FUNCTION: qu2ro
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert quaternion to Rodrigues
!
!> @param q quaternion (single precision)
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 2.0 direct transformation
!> @date 8/11/14   MDG 2.1 added infty handling
!--------------------------------------------------------------------------
recursive function qu2ro(q) result(res)


real(kind=sgl), INTENT(IN)              :: q(4)
real(kind=sgl)                          :: res(4), omega, t, s
real(kind=sgl),parameter                :: thr = 1.0E-8

res(1:3) = q(2:4)
res(4) = 0.0

if (q(1).lt.thr) then
  res(4)=infty
  return
end if

s = sqrt(sum(res(1:3)*res(1:3)))
if (s.lt.thr) then
  res = (/ 0.0, 0.0, 0.0, 0.0 /)
  return
else
  t = tan(acos(q(1)))
  res = (/ res(1)/s, res(2)/s, res(3)/s, t /)
end if

end function qu2ro

!--------------------------------------------------------------------------
!
! FUNCTION: qu2ro_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert quaternion to Rodrigues
!
!> @param q quaternion (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 2.0 direct transformation
!> @date 8/11/14   MDG 2.1 added infty handling
!--------------------------------------------------------------------------
recursive function qu2ro_d(q) result(res)


real(kind=dbl), INTENT(IN)              :: q(4)
real(kind=dbl)                          :: res(4), omega, s, t
real(kind=dbl),parameter                :: thr = 1.0D-10

res(1:3) = q(2:4)
res(4) = 0.D0

if (q(1).lt.thr) then
  res(4)=infty
  return
end if

s = dsqrt(sum(res(1:3)*res(1:3)))
if (s.lt.thr) then
  res = (/ 0.D0, 0.D0, 0.D0, 0.D0 /)
  return
else
  t = dtan(dacos(q(1)))
  res = (/ res(1)/s, res(2)/s, res(3)/s, t /)
end if

end function qu2ro_d

!--------------------------------------------------------------------------
!
! FUNCTION: qu2ho
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert quaternion to homochoric
!
!> @param q quaternion (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 2.0 explicit transformation
!--------------------------------------------------------------------------
recursive function qu2ho(q) result(res)

real(kind=sgl), INTENT(IN)              :: q(4)
real(kind=sgl)                          :: res(3), omega, s, f

omega = 2.0 * acos(q(1))
if (omega.eq.0.0) then
        res = (/ 0.0, 0.0, 0.0 /)
else
        res = q(2:4)
        s = 1.0/sqrt(sum(res**2))
        res = res * s
        f = 0.75 * ( omega - sin(omega) )
        res = res * f**0.333333333
end if

end function qu2ho

!--------------------------------------------------------------------------
!
! FUNCTION: qu2ho_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert quaternion to homochoric
!
!> @param q quaternion (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 7/23/14   MDG 2.0 explicit transformation
!--------------------------------------------------------------------------
recursive function qu2ho_d(q) result(res)

real(kind=dbl), INTENT(IN)              :: q(4)
real(kind=dbl)                          :: res(3), omega, s, f

omega = 2.D0 * dacos(q(1))
if (omega.eq.0.D0) then
        res = (/ 0.D0, 0.D0, 0.D0 /)
else
        res = q(2:4)
        s = 1.D0/dsqrt(sum(res**2))
        res = res * s
        f = 0.75D0 * ( omega - dsin(omega) )
        res = res * f**0.333333333D0
end if

end function qu2ho_d
!--------------------------------------------------------------------------
!
! FUNCTION: ho2cu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to cubochoric
!
!> @param h homochoric coordinates (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2cu(h) result(res)

real(kind=sgl), INTENT(IN)              :: h(3)         !< input
coordinates
real(kind=sgl)                          :: res(3)

integer(kind=irg)                       :: ierr

! calling program must have initialized the Lambert parameters!!!!
!>  
res = LambertBallToCube(h,ierr)

end function ho2cu

!--------------------------------------------------------------------------
!
! FUNCTION: ho2cu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to cubochoric
!
!> @param h homochoric coordinates (double precision)
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2cu_d(h) result(res)

real(kind=dbl), INTENT(IN)              :: h(3)         !< input
coordinates
real(kind=dbl)                          :: res(3)

integer(kind=irg)                       :: ierr

! calling program must have initialized the Lambert parameters!!!!
!>  
res = LambertBallToCube(h,ierr)

end function ho2cu_d

!--------------------------------------------------------------------------
!
! FUNCTION: cu2ho
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to homochoric
!
!> @param c cubochoric coordinates (single precision)
!>  
! 
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2ho(c) result(res)

real(kind=sgl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=sgl)                          :: res(3)

integer(kind=irg)                       :: ierr

! calling program must have initialized the Lambert parameters!!!!
!>  
res = LambertCubeToBall(c,ierr)

end function cu2ho

!--------------------------------------------------------------------------
!
! FUNCTION: cu2ho_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to homochoric
!
!> @param c cubochoric coordinates (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2ho_d(c) result(res)

real(kind=dbl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=dbl)                          :: res(3)

integer(kind=irg)                       :: ierr

! calling program must have initialized the Lambert parameters!!!!
!>  
res = LambertCubeToBall(c,ierr)

end function cu2ho_d


!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
! and here are a bunch of transformation routines that are derived from
! the others
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
!
! Function: ro2eu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Rodrigues vector to Euler angles (single precision)
!
!> @param r Rodrigues vector (single precision)  
!>  
!
!> @date 8/04/13   MDG 1.0 original
!> @date 8/11/14   MDG 1.1 added infty handling
!--------------------------------------------------------------------------
recursive function ro2eu(r) result(res)


IMPLICIT NONE

real(kind=sgl),INTENT(IN)       :: r(4)         !< Rodrigues vector
real(kind=sgl)                  :: res(3)
        
real(kind=sgl)                  :: rr(3), s, d

res = om2eu(ro2om(r))

end function ro2eu

!--------------------------------------------------------------------------
!
! Function: ro2eu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief Rodrigues vector to Euler angles (double precision)
!
!> @param r Rodrigues vector (double precision)  
!>  
! 
!> @date 8/04/13   MDG 1.0 original
!> @date 8/11/14   MDG 1.1 added infty handling
!--------------------------------------------------------------------------
recursive function ro2eu_d(r) result(res)


IMPLICIT NONE

real(kind=dbl),INTENT(IN)       :: r(4)         !< Rodrigues vector
real(kind=dbl)                  :: res(3)

real(kind=dbl)                  :: rr(3), s, d


res = om2eu_d(ro2om_d(r))

end function ro2eu_d

!--------------------------------------------------------------------------
!
! FUNCTION: eu2ho
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert euler to homochoric
!
!> @param e 3 euler angles (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function eu2ho(e) result(res)

real(kind=sgl), INTENT(IN)              :: e(3)
real(kind=sgl)                          :: res(3)

res = ax2ho(eu2ax(e))

end function eu2ho

!--------------------------------------------------------------------------
!
! FUNCTION: eu2ho_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert euler to homochoric
!
!> @param e 3 euler angles (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function eu2ho_d(e) result(res)

real(kind=dbl), INTENT(IN)              :: e(3)
real(kind=dbl)                          :: res(3)

res = ax2ho_d(eu2ax_d(e))

end function eu2ho_d

!--------------------------------------------------------------------------
!
! FUNCTION: om2ro
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert orientation matrix to Rodrigues
!
!> @param om 3x3 orientation matrix (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function om2ro(om) result(res)

real(kind=sgl), INTENT(IN)              :: om(3,3)
real(kind=sgl)                          :: res(4)

res = eu2ro(om2eu(om))

end function om2ro

!--------------------------------------------------------------------------
!
! FUNCTION: om2ro_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert orientation matrix to Rodrigues
!
!> @param om 3x3 orientation matrix (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function om2ro_d(om) result(res)

real(kind=dbl), INTENT(IN)              :: om(3,3)
real(kind=dbl)                          :: res(4)

res = eu2ro_d(om2eu_d(om))

end function om2ro_d

!--------------------------------------------------------------------------
!
! FUNCTION: om2ho
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert orientation matrix to homochoric
!
!> @param om 3x3 orientation matrix (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 07/08/14 MDG 2.0 simplification via ax (shorter path)
!--------------------------------------------------------------------------
recursive function om2ho(om) result(res)

real(kind=sgl), INTENT(IN)              :: om(3,3)
real(kind=sgl)                          :: res(3)

res = ax2ho(om2ax(om))

end function om2ho 

!--------------------------------------------------------------------------
!
! FUNCTION: om2ho_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert orientation matrix to homochoric
!
!> @param om 3x3 orientation matrix (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 07/08/14 MDG 2.0 simplification via ax (shorter path)
!--------------------------------------------------------------------------
recursive function om2ho_d(om) result(res)

real(kind=dbl), INTENT(IN)              :: om(3,3)
real(kind=dbl)                          :: res(3)

res = ax2ho(om2ax(om))

end function om2ho_d

!--------------------------------------------------------------------------
!
! FUNCTION: ax2eu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert axis angle to euler
!
!> @param a axis angle pair (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 07/08/14 MDG 2.0 simplification via ro (shorter path)
!--------------------------------------------------------------------------
recursive function ax2eu(a) result(res)

real(kind=sgl), INTENT(IN)              :: a(4)
real(kind=sgl)                          :: res(3)

res = om2eu(ax2om(a))

end function ax2eu

!--------------------------------------------------------------------------
!
! FUNCTION: ax2eu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert axis angle to euler
!
!> @param a axis angle pair (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!> @date 07/08/14 MDG 2.0 simplification via ro (shorter path)
!--------------------------------------------------------------------------
recursive function ax2eu_d(a) result(res)

real(kind=dbl), INTENT(IN)              :: a(4)
real(kind=dbl)                          :: res(3)

res = om2eu(ax2om(a))

end function ax2eu_d



!--------------------------------------------------------------------------
!
! FUNCTION: ro2om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert rodrigues to orientation matrix
!
!> @param r Rodrigues vector (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ro2om(r) result(res)

real(kind=sgl), INTENT(IN)              :: r(4)
real(kind=sgl)                          :: res(3,3)

res = ax2om(ro2ax(r))

end function ro2om

!--------------------------------------------------------------------------
!
! FUNCTION: ro2om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert rodrigues to orientation matrix
!
!> @param r Rodrigues vector (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ro2om_d(r) result(res)

real(kind=dbl), INTENT(IN)              :: r(4)
real(kind=dbl)                          :: res(3,3)

res = ax2om_d(ro2ax_d(r))

end function ro2om_d


!--------------------------------------------------------------------------
!
! FUNCTION: ro2qu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert rodrigues to quaternion
!
!> @param r Rodrigues vector (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ro2qu(r) result(res)

real(kind=sgl), INTENT(IN)              :: r(4)
real(kind=sgl)                          :: res(4)

res = ax2qu(ro2ax(r))

end function ro2qu


!--------------------------------------------------------------------------
!
! FUNCTION: ro2qu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert rodrigues to quaternion
!
!> @param r Rodrigues vector (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ro2qu_d(r) result(res)

real(kind=dbl), INTENT(IN)              :: r(4)
real(kind=dbl)                          :: res(4)

res = ax2qu_d(ro2ax_d(r))

end function ro2qu_d



!--------------------------------------------------------------------------
!
! FUNCTION: ho2eu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to euler
!
!> @param h homochoric coordinates (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2eu(h) result(res)

real(kind=sgl), INTENT(IN)              :: h(3)
real(kind=sgl)                          :: res(3)

res = ax2eu(ho2ax(h))

end function ho2eu

!--------------------------------------------------------------------------
!
! FUNCTION: ho2eu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to euler
!
!> @param h homochoric coordinates (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2eu_d(h) result(res)

real(kind=dbl), INTENT(IN)              :: h(3)
real(kind=dbl)                          :: res(3)

res = ax2eu_d(ho2ax_d(h))

end function ho2eu_d

!--------------------------------------------------------------------------
!
! FUNCTION: ho2om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to orientation matrix
!
!> @param h homochoric coordinates (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2om(h) result(res)

real(kind=sgl), INTENT(IN)              :: h(3)
real(kind=sgl)                          :: res(3,3)

res = ax2om(ho2ax(h))

end function ho2om

!--------------------------------------------------------------------------
!
! FUNCTION: ho2om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to orientation matrix
!
!> @param h homochoric coordinates (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2om_d(h) result(res)

real(kind=dbl), INTENT(IN)              :: h(3)
real(kind=dbl)                          :: res(3,3)

res = ax2om_d(ho2ax_d(h))

end function ho2om_d

!--------------------------------------------------------------------------
!
! FUNCTION: ho2ro
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to Rodrigues
!
!> @param h homochoric coordinates (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2ro(h) result(res)

real(kind=sgl), INTENT(IN)              :: h(3)
real(kind=sgl)                          :: res(4)

res = ax2ro(ho2ax(h))

end function ho2ro

!--------------------------------------------------------------------------
!
! FUNCTION: ho2ro_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to Rodrigues
!
!> @param h homochoric coordinates (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2ro_d(h) result(res)

real(kind=dbl), INTENT(IN)              :: h(3)
real(kind=dbl)                          :: res(4)

res = ax2ro_d(ho2ax_d(h))

end function ho2ro_d

!--------------------------------------------------------------------------
!
! FUNCTION: ho2qu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to quaternion
!
!> @param h homochoric coordinates (single precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2qu(h) result(res)

real(kind=sgl), INTENT(IN)              :: h(3)
real(kind=sgl)                          :: res(4)

res = ax2qu(ho2ax(h))

end function ho2qu

!--------------------------------------------------------------------------
!
! FUNCTION: ho2qu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert homochoric to quaternion
!
!> @param h homochoric coordinates (double precision)
!>  
! 
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ho2qu_d(h) result(res)

real(kind=dbl), INTENT(IN)              :: h(3)
real(kind=dbl)                          :: res(4)

res = ax2qu_d(ho2ax_d(h))

end function ho2qu_d

!--------------------------------------------------------------------------
!
! FUNCTION: eu2cu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert euler angles to cubochoric
!
!> @param e euler angles (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function eu2cu(e) result(res)

real(kind=sgl), INTENT(IN)              :: e(3)         !< input
coordinates
real(kind=sgl)                          :: res(3)

res = ho2cu(eu2ho(e))

end function eu2cu

!--------------------------------------------------------------------------
!
! FUNCTION: eu2cu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert euler angles to cubochoric
!
!> @param e euler angles (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function eu2cu_d(e) result(res)

real(kind=dbl), INTENT(IN)              :: e(3)         !< input
coordinates
real(kind=dbl)                          :: res(3)

res = ho2cu_d(eu2ho_d(e))

end function eu2cu_d

!--------------------------------------------------------------------------
!
! FUNCTION: om2cu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert orientation matrix to cubochoric
!
!> @param o orientation matrix (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function om2cu(o) result(res)

real(kind=sgl), INTENT(IN)              :: o(3,3)               !< input
coordinates
real(kind=sgl)                          :: res(3)

res = ho2cu(om2ho(o))

end function om2cu

!--------------------------------------------------------------------------
!
! FUNCTION: om2cu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert orientation matrix to cubochoric
!
!> @param o orientation matrix (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function om2cu_d(o) result(res)

real(kind=dbl), INTENT(IN)              :: o(3,3)               !< input
coordinates
real(kind=dbl)                          :: res(3)

res = ho2cu_d(om2ho_d(o))

end function om2cu_d

!--------------------------------------------------------------------------
!
! FUNCTION: ax2cu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert axis angle to cubochoric
!
!> @param a axis angle (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ax2cu(a) result(res)

real(kind=sgl), INTENT(IN)              :: a(4)         !< input
coordinates
real(kind=sgl)                          :: res(3)

res = ho2cu(ax2ho(a))

end function ax2cu

!--------------------------------------------------------------------------
!
! FUNCTION: ax2cu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert axis angle to cubochoric
!
!> @param a axis angle (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ax2cu_d(a) result(res)

real(kind=dbl), INTENT(IN)              :: a(4)         !< input
coordinates
real(kind=dbl)                          :: res(3)

res = ho2cu_d(ax2ho_d(a))

end function ax2cu_d

!--------------------------------------------------------------------------
!
! FUNCTION: ro2cu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert Rodrigues to cubochoric
!
!> @param r Rodrigues (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ro2cu(r) result(res)

real(kind=sgl), INTENT(IN)              :: r(4)         !< input
coordinates
real(kind=sgl)                          :: res(3)

res = ho2cu(ro2ho(r))

end function ro2cu

!--------------------------------------------------------------------------
!
! FUNCTION: ro2cu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert Rodrigues to cubochoric
!
!> @param r Rodrigues (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function ro2cu_d(r) result(res)

real(kind=dbl), INTENT(IN)              :: r(4)         !< input
coordinates
real(kind=dbl)                          :: res(3)

res = ho2cu_d(ro2ho_d(r))

end function ro2cu_d

!--------------------------------------------------------------------------
!
! FUNCTION: qu2cu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert quaternion to cubochoric
!
!> @param q quaternion (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function qu2cu(q) result(res)

real(kind=sgl), INTENT(IN)              :: q(4)         !< input
coordinates
real(kind=sgl)                          :: res(3)

res = ho2cu(qu2ho(q))

end function qu2cu

!--------------------------------------------------------------------------
!
! FUNCTION: qu2cu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert quaternion to cubochoric
!
!> @param q quaternion (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function qu2cu_d(q) result(res)

real(kind=dbl), INTENT(IN)              :: q(4)         !< input
coordinates
real(kind=dbl)                          :: res(3)

res = ho2cu_d(qu2ho_d(q))

end function qu2cu_d


!--------------------------------------------------------------------------
!
! FUNCTION: cu2eu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to euler angles
!
!> @param c cubochoric coordinates (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2eu(c) result(res)

real(kind=sgl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=sgl)                          :: res(3)

res = ho2eu(cu2ho(c))

end function cu2eu

!--------------------------------------------------------------------------
!
! FUNCTION: cu2eu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to euler angles
!
!> @param c cubochoric coordinates (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2eu_d(c) result(res)

real(kind=dbl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=dbl)                          :: res(3)

res = ho2eu_d(cu2ho_d(c))

end function cu2eu_d

!--------------------------------------------------------------------------
!
! FUNCTION: cu2om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to orientation matrix
!
!> @param c cubochoric coordinates (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2om(c) result(res)

real(kind=sgl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=sgl)                          :: res(3,3)

res = ho2om(cu2ho(c))

end function cu2om

!--------------------------------------------------------------------------
!
! FUNCTION: cu2om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to orientation matrix
!
!> @param c cubochoric coordinates  (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2om_d(c) result(res)

real(kind=dbl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=dbl)                          :: res(3,3)

res = ho2om_d(cu2ho_d(c))

end function cu2om_d

!--------------------------------------------------------------------------
!
! FUNCTION: cu2ax
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to axis angle
!
!> @param c cubochoric coordinates (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2ax(c) result(res)

real(kind=sgl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=sgl)                          :: res(4)

res = ho2ax(cu2ho(c))

end function cu2ax

!--------------------------------------------------------------------------
!
! FUNCTION: cu2ax_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to axis angle
!
!> @param c cubochoric coordinates  (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2ax_d(c) result(res)

real(kind=dbl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=dbl)                          :: res(4)

res = ho2ax_d(cu2ho_d(c))

end function cu2ax_d

!--------------------------------------------------------------------------
!
! FUNCTION: cu2ro
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to Rodrigues
!
!> @param c cubochoric coordinates (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2ro(c) result(res)

real(kind=sgl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=sgl)                          :: res(4)

res = ho2ro(cu2ho(c))

end function cu2ro

!--------------------------------------------------------------------------
!
! FUNCTION: cu2ro_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to Rodrigues
!
!> @param c cubochoric coordinates  (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2ro_d(c) result(res)

real(kind=dbl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=dbl)                          :: res(4)

res = ho2ro_d(cu2ho_d(c))

end function cu2ro_d

!--------------------------------------------------------------------------
!
! FUNCTION: cu2qu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to quaternion
!
!> @param c cubochoric coordinates (single precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2qu(c) result(res)

real(kind=sgl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=sgl)                          :: res(4)

res = ho2qu(cu2ho(c))

end function cu2qu

!--------------------------------------------------------------------------
!
! FUNCTION: cu2qu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief convert cubochoric to quaternion
!
!> @param c cubochoric coordinates  (double precision)
!>  
! 
!> @note calling program MUST have initialized the Lambert parameters
!first!!!
!>  
!
!> @date 8/12/13   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function cu2qu_d(c) result(res)

real(kind=dbl), INTENT(IN)              :: c(3)         !< input
coordinates
real(kind=dbl)                          :: res(4)

res = ho2qu_d(cu2ho_d(c))

end function cu2qu_d


!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
! routines for rotating a vector, tensor, ...
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
!
! FUNCTION: RotVec_om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief rotate a vector using a rotation matrix, active or passive
!(single precision)
!
!> @details This routine provides a way for the user to transform a
!vector
!> and it returns the new vector components.  The user can use either a 
!> rotation matrix or a quaternion to define the transformation, and
!must
!> also specifiy whether an active or passive result is needed.
!>
!
!> @param vec input vector components (single precision)
!> @param om orientation matrix (single precision)
!> @param ap active/passive switch
!>  
!
!> @date 8/18/14   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function RotVec_om(vec,om,ap) result(res)

real(kind=sgl),INTENT(IN)       :: vec(3)
real(kind=sgl),INTENT(IN)       :: om(3,3)
character(1),INTENT(IN)         :: ap

real(kind=sgl)                  :: res(3)

if (ap.eq.'p') then
 res = matmul(om,vec)
else
 res = matmul(transpose(om),vec)
end if

end function RotVec_om

!--------------------------------------------------------------------------
!
! FUNCTION: RotVec_om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief rotate a vector using a rotation matrix, active or passive
!(double precision)
!
!> @details This routine provides a way for the user to transform a
!vector
!> and it returns the new vector components.  The user can use either a 
!> rotation matrix or a quaternion to define the transformation, and
!must
!> also specifiy whether an active or passive result is needed.
!>
!
!> @param vec input vector components (double precision)
!> @param om orientation matrix (double precision)
!> @param ap active/passive switch
!>  
!
!> @date 8/18/14   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function RotVec_om_d(vec,om,ap) result(res)

real(kind=dbl),INTENT(IN)       :: vec(3)
real(kind=dbl),INTENT(IN)       :: om(3,3)
character(1),INTENT(IN)         :: ap

real(kind=dbl)                  :: res(3)

if (ap.eq.'p') then
 res = matmul(om,vec)
else
 res = matmul(transpose(om),vec)
end if

end function RotVec_om_d


!--------------------------------------------------------------------------
!
! FUNCTION: RotVec_qu
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief rotate a vector using a quaternion, active or passive (single
!precision)
!
!> @details This routine provides a way for the user to transform a
!vector
!> and it returns the new vector components.  The user can use either a 
!> rotation matrix or a quaternion to define the transformation, and
!must
!> also specifiy whether an active or passive result is needed.
!>
!
!> @param vec input vector components (single precision)
!> @param qu quaternion (single precision)
!> @param ap active/passive switch
!>  
!
!> @date 8/18/14   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function RotVec_qu(vec,qu,ap) result(res)

real(kind=sgl),INTENT(IN)       :: vec(3)
real(kind=sgl),INTENT(IN)       :: qu(4)
character(1),INTENT(IN)         :: ap

real(kind=sgl)                  :: res(3)
real(kind=sgl)                  :: rq(4), rr(4)

rq = (/ 0.0, vec(1), vec(2), vec(3) /)

if (epsijk.lt.0) then
  if (ap.eq.'a') then
    rr = quat_mult(qu,quat_mult(rq,conjg(qu)) )
  else
    rr = quat_mult(conjg(qu),quat_mult(rq,qu) )
  end if
else
  if (ap.eq.'p') then
    rr = quat_mult(qu,quat_mult(rq,conjg(qu)) )
  else
    rr = quat_mult(conjg(qu),quat_mult(rq,qu) )
  end if
end if

res = rr(2:4)

end function RotVec_qu


!--------------------------------------------------------------------------
!
! FUNCTION: RotVec_qu_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief rotate a vector using a quaternion, active or passive (double
!precision)
!
!> @details This routine provides a way for the user to transform a
!vector
!> and it returns the new vector components.  The user can use either a 
!> rotation matrix or a quaternion to define the transformation, and
!must
!> also specifiy whether an active or passive result is needed.
!>
!
!> @param vec input vector components (double precision)
!> @param qu quaternion (double precision)
!> @param ap active/passive switch
!>  
!
!> @date 8/18/14   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function RotVec_qu_d(vec,qu,ap) result(res)

real(kind=dbl),INTENT(IN)       :: vec(3)
real(kind=dbl),INTENT(IN)       :: qu(4)
character(1),INTENT(IN)         :: ap

real(kind=dbl)                  :: res(3)
real(kind=dbl)                  :: rq(4), rr(4)

rq = (/ 0.D0, vec(1), vec(2), vec(3) /)

if (epsijk.lt.0) then
  if (ap.eq.'a') then
    rr = quat_mult(qu,quat_mult(rq,conjg(qu)) )
  else
    rr = quat_mult(conjg(qu),quat_mult(rq,qu) )
  end if
else
  if (ap.eq.'p') then
    rr = quat_mult(qu,quat_mult(rq,conjg(qu)) )
  else
    rr = quat_mult(conjg(qu),quat_mult(rq,qu) )
  end if
end if

res = rr(2:4)

end function RotVec_qu_d

!--------------------------------------------------------------------------
!
! FUNCTION: RotTensor2_om
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief rotate a second rank tensor using a rotation matrix, active or
!passive (single precision)
!
!> @param tensor input tensor components (single precision)
!> @param om orientation matrix (single precision)
!> @param ap active/passive switch
!>  
!
!> @date 8/18/14   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function RotTensor2_om(tensor,om,ap) result(res)

real(kind=sgl),INTENT(IN)       :: tensor(3,3)
real(kind=sgl),INTENT(IN)       :: om(3,3)
character(1),INTENT(IN)         :: ap

real(kind=sgl)                  :: res(3,3)

if (ap.eq.'p') then
 res = matmul(matmul(om,tensor),transpose(om))
else
 res = matmul(matmul(transpose(om),tensor),om)
end if

end function RotTensor2_om


!--------------------------------------------------------------------------
!
! FUNCTION: RotTensor2_om_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief rotate a second rank tensor using a rotation matrix, active or
!passive (double precision)
!
!> @param tensor input tensor components (double precision)
!> @param om orientation matrix (double precision)
!> @param ap active/passive switch
!>  
!
!> @date 8/18/14   MDG 1.0 original
!--------------------------------------------------------------------------
recursive function RotTensor2_om_d(tensor,om,ap) result(res)

real(kind=dbl),INTENT(IN)       :: tensor(3,3)
real(kind=dbl),INTENT(IN)       :: om(3,3)
character(1),INTENT(IN)         :: ap

real(kind=dbl)                  :: res(3,3)

if (ap.eq.'p') then
 res = matmul(matmul(om,tensor),transpose(om))
else
 res = matmul(matmul(transpose(om),tensor),om)
end if

end function RotTensor2_om_d


!--------------------------------------------------------------------------
!--------------------------------------------------------------------------
! and finally some printing routines, mostly used for debugging
!--------------------------------------------------------------------------
!--------------------------------------------------------------------------

!--------------------------------------------------------------------------
!
! SUBROUTINE: print_orientation
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief  prints a complete orientationtype record or a single entry
! 
!> @param o orientationtype record
!> @param outtype (optional) indicates which representation to print
!> @param pretext (optional) up to 10 characters that will precede each
!line
! 
!> @date  8/4/13   MDG 1.0 original
!--------------------------------------------------------------------------
subroutine print_orientation(o,outtype,pretext)

IMPLICIT NONE

type(orientationtype),INTENT(IN)        :: o
character(2),INTENT(IN),OPTIONAL        :: outtype
character(10),INTENT(IN),OPTIONAL       :: pretext

real(kind=sgl)                          :: ioreal(4)
character(10)                           :: pret

pret = ''
if (present(pretext)) pret=trim(pretext)

if (present(outtype)) then
  select case (outtype)
        case ('eu')
          ioreal(1:3) = o%eulang(1:3)*180.0/sngl(cPi)
          call WriteValue(trim(pret)//'Euler angles [deg]
: ', ioreal, 3, "(3(F8.4,' '))")

        case ('ax')
          ioreal(1:4) = o%axang(1:4)
          ioreal(4) = ioreal(4)*180.0/sngl(cPi)
          call WriteValue(trim(pret)//'Axis angle pair [n; angle (deg)]
: ', ioreal, 4, "(3(F8.4,' '),'; ',F8.4)")

        case ('ro')
          if (o%rodrigues(4).ne.infty) then
            ioreal(1:3) = o%rodrigues(1:3)*o%rodrigues(4)
            call WriteValue(trim(pret)//'Rodrigues vector
: ', ioreal, 3, "(3(F12.4,' '))")
          else
            ioreal(1:4) = o%rodrigues(1:4)
            call WriteValue(trim(pret)//'Rodrigues vector [n; tan(w/2)]
: ', ioreal, 4, "(3(F12.4,' '),';',F12.4)")
          end if

        case ('ho')
          ioreal(1:3) = o%homochoric(1:3)
          call WriteValue(trim(pret)//'Homochoric vector
: ', ioreal, 3, "(3(F8.4,' '))")

        case ('cu')
          ioreal(1:3) = o%cubochoric(1:3)
          call WriteValue(trim(pret)//'Cubochoric vector
: ', ioreal, 3, "(3(F8.4,' '))")

        case ('qu')
          ioreal(1:4) = o%quat
          call WriteValue(trim(pret)//'Quaternion [scalar, vector]
: ', ioreal, 4, "(4(F8.4,' '))")

        case ('om')
          ioreal(1:3) = o%om(1,1:3)
          call WriteValue('                                       /',
ioreal, 3, "(2(F8.4,' '),F8.4,' \')")
          ioreal(1:3) = o%om(2,1:3)
          call WriteValue(trim(pret)//'Orientation Matrix
: |', ioreal, 3, "(2(F8.4,' '),F8.4,' |')")
          ioreal(1:3) = o%om(3,1:3)
          call WriteValue('                                       \',
ioreal, 3, "(2(F8.4,' '),F8.4,' /')")
                                
  end select
else
! print the entire record with all representations
  ioreal(1:3) = o%eulang(1:3)*180.0/sngl(cPi)
  call WriteValue(trim(pret)//'Euler angles [deg]               : ',
ioreal, 3, "(3(F8.4,' '))")
  ioreal(1:4) = o%axang(1:4)
  ioreal(4) = ioreal(4)*180.0/sngl(cPi)
  call WriteValue(trim(pret)//'Axis angle pair [n; angle (deg)] : ',
ioreal, 4, "(3(F8.4,' '),'; ',F8.4)")
  if (o%rodrigues(4).ne.infty) then
   ioreal(1:3) = o%rodrigues(1:3)*o%rodrigues(4)
   call WriteValue(trim(pret)//'Rodrigues vector                 : ',
ioreal, 3, "(3(F12.4,' '))")
  else
   ioreal(1:4) = o%rodrigues(1:4)
   call WriteValue(trim(pret)//'Rodrigues vector [n; tan(w/2)]   : ',
ioreal, 4, "(3(F12.4,' '),';',F12.4)")
  end if
  ioreal(1:3) = o%homochoric(1:3)
  call WriteValue(trim(pret)//'Homochoric vector                : ',
ioreal, 3, "(3(F8.4,' '))")
  ioreal(1:3) = o%cubochoric(1:3)
  call WriteValue(trim(pret)//'Cubochoric vector                : ',
ioreal, 3, "(3(F8.4,' '))")
  ioreal(1:4) = o%quat
  call WriteValue(trim(pret)//'Quaternion [scalar, vector]      : ',
ioreal, 4, "(4(F8.4,' '))")
  ioreal(1:3) = o%om(1,1:3)
  call WriteValue('                                   /', ioreal, 3,
"(2(F8.4,' '),F8.4,' \')")
  ioreal(1:3) = o%om(2,1:3)
  call WriteValue(trim(pret)//'Orientation Matrix               : |',
ioreal, 3, "(2(F8.4,' '),F8.4,' |')")
  ioreal(1:3) = o%om(3,1:3)
  call WriteValue('                                   \', ioreal, 3,
"(2(F8.4,' '),F8.4,' /')")
end if

call Message(' ', frm = "(A/)")

end subroutine print_orientation

!--------------------------------------------------------------------------
!
! SUBROUTINE: print_orientation_d
!
!> @author Marc De Graef, Carnegie Mellon University
!
!> @brief  prints a complete orientationtype record or a single entry
!(double precision)
! 
!> @param o orientationtype record
!> @param outtype (optional) indicates which representation to print
!> @param pretext (optional) up to 10 characters that will precede each
!line
!
!> @date  8/4/13   MDG 1.0 original
!--------------------------------------------------------------------------
subroutine print_orientation_d(o,outtype,pretext)

IMPLICIT NONE

type(orientationtyped),INTENT(IN)       :: o
character(2),INTENT(IN),OPTIONAL        :: outtype
character(10),INTENT(IN),OPTIONAL       :: pretext

real(kind=dbl)                          :: ioreal(4)
character(10)                           :: pret

pret = ''
if (present(pretext)) pret=trim(pretext)

if (present(outtype)) then
  select case (outtype)
        case ('eu')
          ioreal(1:3) = o%eulang(1:3)*180.D0/cPi
          call WriteValue(trim(pret)//'Euler angles  [deg]
: ', ioreal, 3, "(3(F12.7,' '))")

        case ('ax')
          ioreal(1:4) = o%axang(1:4)
          ioreal(4) = ioreal(4)*180.D0/cPi
          call WriteValue(trim(pret)//'Axis angle pair [n; angle (deg)]
: ', ioreal, 4, "(3(F12.7,' '),'; ',F12.7)")

        case ('ro')
          if (o%rodrigues(4).ne.infty) then 
           ioreal(1:3) = o%rodrigues(1:3)*o%rodrigues(4)
           call WriteValue(trim(pret)//'Rodrigues vector
: ', ioreal, 3, "(3(F16.7,' '))")
          else
           ioreal(1:4) = o%rodrigues(1:4)
           call WriteValue(trim(pret)//'Rodrigues vector [n; tan(w/2)]
: ', ioreal, 4, "(3(F16.7,' '),';',F16.7)")
          end if

        case ('ho')
          ioreal(1:3) = o%homochoric(1:3)
          call WriteValue(trim(pret)//'Homochoric vector
: ', ioreal, 3, "(3(F12.7,' '))")

        case ('cu')
          ioreal(1:3) = o%cubochoric(1:3)
          call WriteValue(trim(pret)//'Cubochoric vector
: ', ioreal, 3, "(3(F12.7,' '))")

        case ('qu')
          ioreal(1:4) = o%quat
          call WriteValue(trim(pret)//'Quaternion [scalar, vector]
: ', ioreal, 4, "(4(F12.7,' '))")

        case ('om')
          ioreal(1:3) = o%om(1,1:3)
          call WriteValue('                                       /',
ioreal, 3, "(2(F8.4,' '),F8.4,' \')")
          ioreal(1:3) = o%om(2,1:3)
          call WriteValue(trim(pret)//'Orientation Matrix
: |', ioreal, 3, "(2(F8.4,' '),F8.4,' |')")
          ioreal(1:3) = o%om(3,1:3)
          call WriteValue('                                       \',
ioreal, 3, "(2(F8.4,' '),F8.4,' /')")
                                
  end select
else
! print the entire record with all representations
  ioreal(1:3) = o%eulang(1:3)*180.D0/cPi
  call WriteValue(trim(pret)//'Euler angles [deg]               : ',
ioreal, 3, "(3(F12.7,' '))")
  ioreal(1:4) = o%axang(1:4)
  ioreal(4) = ioreal(4)*180.D0/cPi
  call WriteValue(trim(pret)//'Axis angle pair [n; angle (deg)] : ',
ioreal, 4, "(3(F12.7,' '),'; ',F12.7)")
  if (o%rodrigues(4).ne.infty) then 
   ioreal(1:3) = o%rodrigues(1:3)*o%rodrigues(4)
   call WriteValue(trim(pret)//'Rodrigues vector                 : ',
ioreal, 3, "(3(F16.7,' '))")
  else
   ioreal(1:4) = o%rodrigues(1:4)
   call WriteValue(trim(pret)//'Rodrigues vector [n; tan(w/2)]   : ',
ioreal, 4, "(3(F16.7,' '),';',F16.7)")
  end if
  ioreal(1:3) = o%homochoric(1:3)
  call WriteValue(trim(pret)//'Homochoric vector                : ',
ioreal, 3, "(3(F12.7,' '))")
  ioreal(1:3) = o%cubochoric(1:3)
  call WriteValue(trim(pret)//'Cubochoric vector                : ',
ioreal, 3, "(3(F12.7,' '))")
  ioreal(1:4) = o%quat
  call WriteValue(trim(pret)//'Quaternion [scalar, vector]      : ',
ioreal, 4, "(4(F12.7,' '))")
  ioreal(1:3) = o%om(1,1:3)
  call WriteValue('                                   /', ioreal, 3,
"(2(F8.4,' '),F8.4,' \')")
  ioreal(1:3) = o%om(2,1:3)
  call WriteValue(trim(pret)//'Orientation Matrix               : |',
ioreal, 3, "(2(F8.4,' '),F8.4,' |')")
  ioreal(1:3) = o%om(3,1:3)
  call WriteValue('                                   \', ioreal, 3,
"(2(F8.4,' '),F8.4,' /')")
end if

call Message(' ', frm = "(A/)")

end subroutine print_orientation_d



end module rotations3D

